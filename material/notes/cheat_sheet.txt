------------------------------------------------------------------------------------------
Chapter 1: Declarations and Access Control
------------------------------------------------------------------------------------------
> An identifier must start with a letter, $ or _. They cannot start with a number.
> short is always -32768 to 32767. It is NOT platform dependent. ALL PRIMITIVE DATATYPES are the same on all platforms.
> Integer caches -128 to 127 objects created through any other means than new operator
  (autoboxed literals, Integer.valueOf("")), meaning same object will be returned
> Void is not a wrapper class. The only ones are: Byte, Short, Integer, Long, Float, Double, Character and Boolean
> bool is not a keyword!!! boolean IS the type you want
> NULL is not a keyword. Only lowercase null is. This rule can be applied to any keyword.
> A java identifier cannot start with a digit (be it class, method, variable, etc.)
- _ and $ are valid at any position!
- Java identifiers cannot be keywords. "const" is a keyword, though with no effect in java 6
- parseInt returns primitive int, valueOf returns wrapper (Integer)
- parseInt, constructor(String) can throw NumberFormatException if string is invalid
> Permitted access modifiers for top level classes are only: public and (package-private)
> Default constructor always inherits access modifier of class
> if you implement an interface you must declare the methods public. leaving them package-private is c. ERROR
> A final class field must always be explicitly initialized inline, in constructor or in initializer
> Interface implicits!!!
- REMEMBER: constants in interfaces are NOT necessary to be declared public static final, but any or none of these (rest of modifiers will be added auto)
- REMEMBER: methods in an interface are NOT necessary to be declared public abstract, but any or none of these (rest of modifiers will be added auto)
- ANY OTHER MODIFIERS like private/protected for the above cases will result in COMPILER ERROR 
> strictfp can be applied to methods, classes and interfaces
> If a class is not public (say package-private), its public variables will NOT be available to ANY class (in this case, only to classes in the package) 
> Local (method) variables are also called automatic variables
> abstract method cannot be native or strictfp
> native methods may be used for computationally intensive jobs, acces to drivers, legacy apps written in other langs
> a protected variable of the Base class will still not be accessible from a Base instance in a derived class FROM OUTSIDE THE PACKAGE 
- using an instance of the derived type will correctly give access to the base class field
> private means private to the class and not to the object. Meaning that you can access the private field of a passed parameter object in a method of the same class as it
> there is no such thing as unsigned in Java
> static initializer of class which is not actively used (Just a reference of it set to null for example) will NOT be called
- ATTENTION: ACTIVE USE MEANS ONLY own (not superclass) method/constructor calls and own NON-STATIC field reading/assigning. All others, like constant reading/superclass actions are not active uses!
  This applies to interfaces and classes alike.
> You cannot throw exceptions explicitly from initializers (static or not). it will give compiler error!!!
> /*/* / * ***//*/ is a valid comment as anything inside /* and  */ is successfully commented
- any runtime exceptions that may occur will be wrapped in an ExceptionInInitializerError
> If the signature of the main method is not valid and we try to run the class using "java", we get java.lang.NoSuchMethodError! Note that the class compiled.
> Java does NOT support chained initialization declaration like: int a = b = c = 100;
- it does however allow it outside initialization (by chaining the operator = which returns the assigned value);
> In an array declaration, the expression from the left of the [ is fully evaluated, then the one in the brackets, and only in the end the indexed get!!! 
- that's why a[(a=b)[1]] will still refer to elements in the old a
> the expressions in the brackets, when creating a new array, DO NOT HAVE TO BE CONSTANTS, and will be evaluated left to right
> if you have a function call func(a, a=b), the first parameter will already have been fully evaluated/passed (from left to right) and old value will be used!!!
> You can create an array of length 0
> Native methods don't specify a body, else compiler error; also, keep in mind that they can be declared in non-abstract classes
> you CAN declare a static field as transient even though it doesn't make much sense
> Multidimensional array initialization must specify the dimension starting from at least the first bracket. e.g. int[][] a = new int [3][];
- specifying dimensions for the other (more to the right) dimensions is only possible if the first ones are specified
> Multiple array declarations like int[] a, b[] will further consider type[], making b bidimensional
> Integer or Long wrapper classes have .toBinaryString, toHexString and toOctalString() methods
- also Integer and Long wrapper classes have toString(int/long, radix) static methods to output the numbers in other radixes
> unboxing is prefered when doing == between a primitive and a wrapper. 
- you should watch out for NullPointerException though if the wrapper is null
> If you define your own no-arg constructor of a public class, and do not set it public (leaving it package-private), classes from other packages will
  not be able to instantiate it. Even more, derived classes will not be able to call this constructor from theirs so they will not compile
> JavaBeans listeners standards are: PUBLIC void addXXXListener(XXXListener) and PUBLIC void removeXXXListener(XXXListener)
- PAY ATTENTION that SET, GET and listener methods must be public
> parameters = what must accept, arguments = what is passed
> constructors can't be marked static, abstract, final or strictfp! ONLY access modifiers are allowed!
> enums cannot be declared inside methods
> you can't invoke an enum constructor directly
> Java.lang package is imported automatically, no need for an import statement.
> You can't use in a derived class constructor's this(...) or super(...) call FIELD from the BASE CLASS at they are not initialized yet => c. error
> A reference counts as a reference even if it has no value attached
> In class declaration syntax, you first EXTEND, then IMPLEMENT, else compiler ERROR.

------------------------------------------------------------------------------------------
Chapter 2: Object Orientation
------------------------------------------------------------------------------------------
> if A<B<C in inheritance hierarchy, an object of class c will not be able to access public variable i from A if B shadows it with a private one
> order of initialization is: static fields+initializers in the order declared, inline declarations+initializers i.o.d, constructor
- if the used class extends another class the statics of that class will run first
- the inline field initializations+initializer blocks will run AFTER the superclass constructor and before the current class Constructor
  so the superclass' ones will always run first.
> It is legal for ANY class to refer to this also as ClassName.this
> you cannot hide a method using static method in the derived class! 
- the reverse is also true; you also cannot hide a static method using a method.
> In order to override, the parameters of the derived method should be exactly the same. (Parameter type invariance)
- Covariant (more derived) or contravariant (ancestor type) parameters are NOT valid overrides, BUT LEGAL OVERLOADS!!!
- Covariant return types are permitted but only for objects! NOT FOR PRIMITIVES.
- Covariant return types are only supported since Java 1.5. Before, they gave compiler error
- Contravariant return types are NOT permitted
- Legal signature of equals is always: public boolean equals(Object other); you cannot use class type as parameter
> super and this cannot be used from a static context (like main)
> You CAN'T do "this.super" or "var.super"
> You CAN'T call super-superclass's method if it was overriden by superclass!!!
> No comma (,) between extends and implements. Comma is used only to separate multiple interfaces
> No multiple use of implements keyword. Use comma for multiple interfaces
> An interface can extend multiple other interfaces
> Interface methods CAN declare exceptions!
> If a class implements multiple interfaces and each define the same method but with different thrown exceptions:
  the class can AT MOST declare all exceptions compatible with all the interfaces separately (or of course lesser exceptions / none)
> It's a compiler error to assign a new Base object to a derived reference. If you cast => ClassCastExc at runtime
> Finalize
- class Object's finalize throws Throwable, so if you call if by super you also have to declare throws Throwable it in the subclass' finalize
- class Object's finalize is protected!
- You can call finalize by hand BUT it acts just as a simple method call (no special meaning)
- GC will only run finalize once (it remebers this)
- Objects can be saved from GC during finalization. The next time object is gc, finalize will not be called.
> Default equals = equal objects by memory address, default hashcode = memory address casted to int
> Default hashCode and equals are legal implementations, but hard to use. Overriding identical behavior is ok.
> IF a.equals(b) then a.hashCode() == b.hashCode(). If you override equals then you must override hashcode!
> By hashcode you identify the bucket (reducing time), then by equals you iterate to really find the object/key
> If a base class has a parameterized constructor, derivatives need to invoke it.
- It is valid that subclass can indirectly invoke the base parameterized constructor through another of its
  constructors, that call super(...) as it's first statement.
> BE CAREFUL of private constructors/method calls in the same class as the main method! they work!
> When calling super(...) constructor in the derived constructor, you CANNOT use expressions regarding intance methods/fields! 
- Statics and ofc current constructor params are ok.
> Abstract classes' constructos will be called when instantiating non-abstract subclasses
> Strings declared inside a block/method will NOT be available for garbage collection (in java 6 anyway) after the method/block ends
> Objects that have references to them might still be garbage collected if those references are from objects also g.c. eligible (islands)
> You can ask for gc by either using System.gc() or Runtime.getRuntime().gc()
> Finally is not guaranteed to run, for example if you call System.exit(0) it won't run
> The only guaranteed thing about gc may be that if you are getting close to filling the memory the gc will run
> No mechanisms will force a right-here-right-now garbage collection!!!
> The algorithm for garbage collection is JVM-specific. It is NOT (always) mark-and-sweep.
> When declaring enums, there must always be a ";" after the enum values if class code follows
- this applies even if the last enum value overrides a method and ends with }. This means }; is correct.
- Unlike a regular java class, you cannot access a non-final static field from an enum's constructor. 
- Quick note: the other known case where ; follows } is when declaring an ANONYMOUS (not named-local) class AND assigning it to a reference!!!
> A is-like-a I usually means A implements I so A can be used for all purposes like an I 
> HARD: using a constant from an INTERFACE that extends another interface will not execute the initialization of the constants for the base interface
- even more, if we refer to a constant of a base INTERFACE through the derived interface (POSSIBLE!) the derived constants initialization will not take place, only the BASE ones which are used actively
> private methods are not inherited, so essentially you can refefine them (not overriding) in the derived class
- this being said it's legal to redefine even a base method marked as private final
> Object.clone() is PROTECTED and throws CloneNotSupportedException.
- to make clone work, you implement MARKER clonable interface in the class you want
- then you make a PUBLIC Clazz clone() method in which you do a try { Clazz clone = (Clazz) super.clone() } to get the clone of the current object (a shallow copy)
- to deep copy some fields, you manually assign them insid the try doing clone.dog = (Dog) dog.clone();
> You can have a field initialized as: String f = this.toString()

------------------------------------------------------------------------------------------
Chapter 3: Assignments
------------------------------------------------------------------------------------------
> Order of signature matching:
- Phase 1: Identify Matching Arity Methods Applicable by widening (ignores varargs and boxing/unboxing)
- Phase 2: Identify Matching Arity Methods Applicable by Method Invocation Conversion (ignores varargs, respects boxing/unboxing)
- Phase 3: Identify Applicable Variable Arity Methods
> So, widening is preferred to boxing and when an exact match isn't found, the JVM uses the method with the smallest argument that is wider
> You can't widen then box, but you can box/unbox then widen! REMEMBER FIRST you BOX!!!
> Varargs must be last argument and there can only be one varargs per method!
> Varargs are always considered last in overloading, even when we also have (Object) sgntr
> When you get to phase 3 (varargs) you can use boxing / widening also and the vararg method chosen will ofc prefer widening vararg over boxing vararg
- e.g. you CAN int -> Integer -> Object (assigning to superclass is considered widening in wrappers)
- but you can't short -> long -> Long
- Integer (wrapper) increment and postincrement WORK! they really assign the value (create new obj).
> always think x+=y as x = (t) (x + y) and x++ as x = (t) (x+1)
> Boolean.valueOf or the constructor(String) of boolean returns true for a case insensitive tRuE, else false, never null. BUT NullPointerException if parameter is null
> something like a [ (a=b) [k] ] where a and b are arrays will make a [...] still refer to the original a, and not b!!!
> new Short(9) is not ok, because 9 is considered an int. EXPLICIT cast is needed new Short((short) 9); applies to other as well
> dividing two floats and then multiplying the result to get to the initial float WORKS! THE SAME IS NOT TRUE FOR DOUBLES due to higher precision.
- e.g. float f = 1.0F / 3.0F; syso(f* 3.0F == 1.0F) will return true!
> casting a float of Integer.MAXVALUE to int and then comparing it to Integer.MAXVALUE will result TRUE.
> watch out for casting a big int to float then back to int. THEY WILL MOST LIKELY NOT BE EQUAL due to the way floating point vars are stored.
> Java performs implicit narrowing conversions of primitives when the context requires it when the value is the result of a constant expression only
> a char can always be assigned to an int. 
> The reverse is true only for compile-time constants (inline literal initialization) if the int is between 0 and 65535 (unsigned short)
- ints only upto 65565 - which is short maxvalue will cast directly to char; higher ints will give compile error.
> THE RULE IS that for compile time constants, int can be automatically inline assigned to: 
  byte (-128 to 127), short(-32768 to 32767), char (0 to 65535)
> For dynamic (non-compile-time-constant) primitive conversion that narrows, an explicit cast is needed as in any narrowing
- that means that char c = a * b where a and b are ints will not work because it's a runtime determined value!!!
> for hex values, you can declare them Case Insensitive: 0XDeadCafe
> valid suffixes (Case Insensitive) are: L (long), F (float), D (double). F is needed to initialize a float literal because double is default!!! e.g. float f = 1.0; => ERROR
- they can be applied also to oktal or hex numbers
- THERE IS NO BINARY LITERAL IN JAVA 6. only in 7+: 0b11 = 3. FORGET USING IT!!!
> Comma CANNOT be used in integer literals - you might think as thousands separator. => Compiler error
> char d = (char) -98; is RIDICULOUS, but LEGAL;  the cast is needed as the number isn't between 0 and 65535
> any operation involving anything int-sized or smaller is always an int. e.g. byte * short
- any operation involving anything int-sized or smaller is always a long. e.g. char * long (YES, CHAR CAN BE USED IN ARITHMETHICS, just like a number)
- any operation involving float or smaller is always a float.
- any operation involving double is always a double!
> The unary minus operator (negation), or the unary plus operator (no effect) applied to a short results in an int. Same rules as above also apply! BE CAREFUL!  
> when printing floats/doubles (especially ones casted from integer values), they always print at least one 0 decimal. e.g. (double) 1L prints 1.0
> In 2's complement: 
- to find out the value of a negative number using two's complement notation, you flip all of the bits and then add 1.
- the reverse it also true! To get from 5 to -5 you flip the bits of 5 and add one.
- For somevar = Integer.MIN_VALUE, -somevar (minus somevar) will be == to somevar, which is Integer.MIN_VALUE!!! this happens only for MIN_VALUE for reason of 2's complement
> For assigning references, you can assign a subclass of the declared type, but not a superclass of the declared type
> All the numeric wrapper classes have .floatValue, .intValue, .shortValue, etc. to convert any numeric type to any other numeric primitive type
> If you define two overloads with (int,long) and (long,int) params and call those with (int,int) params, you get compiler error => Ambiguous overloads!!!
- If you define single param overloads of multiple classes in a hierararchy, if you call it with null the most specific subclass will be called
  you can do an explicit cast on null to force the compiler to select one overload, in case the overload is ambigous (different hierarchies)

------------------------------------------------------------------------------------------
Chapter 4: Operators
------------------------------------------------------------------------------------------
> == has less precedence than < > or other operators so (true == 2 < 4) is ok and true
> if i==1 then i++ + ++i is 4
> == between objects of different class hierarchies, like Integer and Byte will cause compiler error!
> Compound assignment operators like *= evaluate the right expression first. e.g.: a * = b + c is in fact a = a * (b + c)
> You can compare a character to any number, including floats/doubles
> if a float 1.0 and an int 1 are considered equal. Similar things apply for other primitives equality
> You can't compare anything with anything like int with Object
> the assignment operator (=) has the least precedence. left, then right members will be fully evaluated first.
> You can use logical or (xor) "^" to return true from mixing two different valued booleans
> << and >>> are actually the opposites. >> keeps sign bit, >>> has more force and pulls it
> operator >>>= indeed exists! :O
> Correct syntax is a instanceof ClassNameOnly-NotAVariableNotAnExpression. NO PARANTHESIS~~!
- it will return true if a is a ClassNameOnly (or a subclass of it).
- ATTENTION: instanceof will give compiler error if right member Class is not assignable from the left member class
- instanceof inside base class constructor will know that it is a whether class being constructed and it will return true if so
- a null check is NOT required when calling instanceof
> ~ only applies to ints (bitwise not)
> *, / and % all have the same level of precedence
> All NaNs (like Float.NaN) are incomparable, returning false when compared with == either as primitive or object
- yes indeed you can assign Float.NaN to a primitive. It is not a real number (it cannot be compared) and will print NaN. Any operations on it will also result in NaN.
- f.equals(g) will return true if both f and g are Float.NaN. This is THE ONE exception of equals of Floats!
- The other is that if a Float representing 0.0f and the other -0.0f will be false when applying equals(), even though == on their .floatValue()s will be true
- there is no Integer.NaN or Long.NaN
> .equals between different primitive wrappers will return false even though they store the same value
> Integer + Integer (wrapper addition) works well, EVEN FOR DIFFERENT WRAPPER CLASSES, like Long and Integer

------------------------------------------------------------------------------------------
Chapter 5: Flow Control, Exceptions, and Assertions
------------------------------------------------------------------------------------------
> short circuit &&/|| will ignore the rest of the line even for complex remaining boolean expressions. e.g.: a && b | c will stop at a if a is false
> you can call instance methods in inline field initialization, and they will use the state variables initialized until reaching the current var initialization
- for inline initialized variables after the current initialization, it will not know about this and will use default values (0 / null)
> you can label: { } block, and IT IS LEGAL TO do break label; from a loop inside this block and it will go the the end of the block  
- you can also break out of a simple LABELED block, with no loop inside required!!! IT MUST BE LABELED!
> JAVA has "goto" reseved keyword BUT IT DOES NOTHING, will just give syntax error!
> Assertions should gen. be used to validate private method args. Validating public input is inappropriate (e.g. args of main)
- Assertions like "assert false" are appropriate to use in any method to mark a location where code should not reach.
- asserting a false statement throws AssertionError => program exits unless the error is caught
- asserting a modifying statement is bad practice. code will only modify is assertions are enabled.
- syntax is assert boolean_statement : non_void_return_statement where the 2nd will print to screen (usually a string)
- you can optionally enclose the boolean statement inside paranthesis!!! keep in mind that this is unlike instanceof where paranthesis are NOT OK!
- the 2nd expression can call modifiable code, but usually it doesn't matter anymore as the program doesn't catch the error and exits
> while(false) and for(;false;) are illegal. if(false) and do{}while(false)are legal!!
- for if(true) throw RuntimeException, any code following will NOT be considered UNREACHABLE! WHAT A HACK! :O
> for(int a = 0, b = 4 ; ; expression(), expression2()) is the correct syntax
- multiple declared variables are permitted but only of the SAME type.
- redefinition of other variables from the parent scope is illegal and is a tricky exam catch!!
- WATCH OUT FOR reusing FOR incrementing variables after closing the for scope!!! => Compile error!
- multiple incrementing expressions are permitted, and they don't have to necessarily increment
- multiple check expressions are NOT PERMITTED
- the last 2 things that happen in a for loop that ends normally is executing the incrementing expression(s) and checking the condition
> You can add a throws declaration for any checked exception, even though it is not really thrown anywhere
> Throwable is checked!!! only derived from RuntimeException or Error are unchecked.
> Order of caught exception MUST be from narrower to broader!!! else COMPILE ERROR!
> When you throw exceptions from the finally block, any exceptions thrown in the try are FORGOTTEN and only the finally one propagates!
- same thing for returning values, the value from the FINALLY block WILL BE THE ONE RETURNED
> in switch it's "default:" not "case default:"
> a SWITCH's case values must be compile-time constants (either class constants or final automatic vars with LITERAL(!) values.
- also they must be of compatible type as switched(x) x value. e.g. switch(byte) { case 128: } will not compile (as 128 > byte)  
> you cannot use a long, float or double as a switch expression
> a SWITCH with no case (an empty switch) IS OKAY (COMPILABLE)
> a SWITCH cannot have any other declarations before a label. a label must be the first instruction inside it
> a SWITCH cannot have multiple labels for the same value!!!
> switching on a postincrement expression will apply the incrementation after executing the code in a case!!!
> you can switch on a boxed number, it will be unboxed!
> YOU CAN SWITCH ON A CONSTANT!!! e.g. switch(1) {}
> it's legal (though not required) to have code blocks after switch cases. e.g.  case SOMETHING: { /* code here */ }
> variables declared in previous switch cases are reusable even after break
- they however MUST be reinitialized explicitly in each case (even if a break was not used in the declaring case)
> You CANNOT use a previously declared variable e.g. "o" in a for each loop, example for(o : c) { }
> You CAN use a final modifier on a foreach loop (only FOREACH, not for), example for (final Object o : c) { }
> throwing null/Null exception is legal compilation but will result in NullPointerException at runtime.
> AssertionError is considered a programmer-thrown error

------------------------------------------------------------------------------------------
Chapter 6: Strings, I/O, Formatting and Parsing (API)
------------------------------------------------------------------------------------------
> java.util.Date is NOT immutable; it uses alterable epoch time
- Date(long milliseconds) is a valid constructor
- you can use getTime() to get the long value of milliseconds
- you can use setTime(long milliseconds) to modify the current date to other milliseconds value!!! 

> java.util.Calendar
- you obtain it using Calendar.getInstance();
- you can set date to it using calendar.setTime(date)
- you can also use calendar.set(year, month, day) BUT REMEMBER MONTH STARTS AT 0 (ZERO) or you could use Calendar.JANUARY
- c.add(Calendar.HOUR, 1) or c.roll(Calendar.MONTH, 11) works; roll is like add only it leaves larger units as it and recycles through specified unit
- c.get(Calendar.DAY_OF_MONTH) returns day of month(e.g.31); you don't have to know all fields for exam
- c.set(Calendar.MONTH,0) sets the month to January
- calendar.getTime() obtains a Date represented by this calendar

> java.text.DateFormat
- BOTH DateFormat and NumberFormat CAN ONLY set LOCALE at the moment of instantiation!!! The is NO METHOD TO CHANGE IT AFTERWARDS
- DateFormat.getDateInstance(), DateFormat.getDateInstance(int DateFormat.LONG) return date formats for default locale
- DateFormat.getDateInstance(int DateFormat.LONG, locale); will get a Dateformat object for that
- same for DateFormat.getTimeInstance(...), they still use the following int DateFormat.* constants for time formats (please infer)
- getDateTimeInstance(...) also exists and it's the only one that retains time!!!
- SHORT = 12.13.52, MEDIUM (default for getDATEInstance() = Jan 12, 1952, LONG = January 12, 1952, FULL = Tuesday, April 12, 1952 AD
- DateFormat.getInstance() exist... but without params, uses SHORT for both date and time formatting! not used frequently
- df.parse("string") will return a Date and will throw checked exception ParseException!!! treat it!
- df.format(java.util.Date) that returns a formatted date String

> java.text.NumberFormat
- NumberFormat.getInstance(locale) gets number formatter for specific locale
- NumberFormat.getCurrencyInstance(locale) gets number formatter for specific locale; curiosity: f.setCurrency(Currency.getInstance("EUR")) can further set currency
- NumberFormat.getPercentInstance(locale) also exists.
- There are methods .getInstance() and .getCurrencyInstance() - and will use current locale
- nf.parse returns a Number, the kind of what it has parsed
- you can use nf.setParseIntegerOnly(true) to only further consider integer parts of floating point number strings
- nf.format(Number) that returns a formatted number String; throws arithmetic exc if roundingmode is set to unnecessary
- nf.setRoundingMode(RoundingMode) can set rounding mode; IF NOT SPECIFIED IS HALF_EVEN. round up usually, unless 0.5 then round to nearest EVEN number
- nf.setMaximumFractionDigits and nf.setMinimumFractionDigits will be respected, ROUNDING WILL BE APPLIED when using format(...)
- Math.round's / round half up rounds negative numbers towards zero. e.g. 0.5 -> 0
> NumberFormat / DateFormat classes extend the java.text.Format class

> java.util.Locale
- getDefault() gets current default locale!!! remember JUST getDefault()!!!
- new Locale(language); or Locale(language, country);
- example new Locale("it","CH"); // Switzerland
- you can also use Locale.CANADA constants for some important countries
- there are also methods loc.getDisplayCountry() and loc.getDisplayLanguage() that will return the name of country/language in cur locale (english)
- to return the name of country/language in other locales, you can use the parameterized versions like getDisplayLanguage(otherLocale) 

> To get -D passed properties you do: System.getProperty("x") or System.getProperties().getProperty("x")
- you use System.getenv("var"); [ yes with non capital env ] to a an environment variable

> StringBuilder
- notable methods: append(String), insert(int,String), reverse(), delete(startIncl, end), toString()
- replace(...) with 2 args(what,withwhat) or 3 args(first,lastNotIncl,withwhat)
- replace returns same object if no change is being done!!! ATTENTION: the input and resulting strings will be equals using == reference comparator
- IT DOES NOT contain the trim() method
- setLength(int) method resizes the stored string, either truncating or filling with NUL (ascii 0) chars
- is only available from java 1.5 onward
> MOST FILE OPERATIONS THROW EXCEPTIONS
> File
- is immutable, the abstract pathname will be set in place after creation. New File objects will be required for traversing the file system
- constructors (string) or (File directory, String)
- has methods exists(); createNewFile() - which really creates,equals then updated returns true if created;
- file cannot be closed, only readers and writers do
- Directories. You can use the following methods on File: boolean mkdir() - creates one folder, mkdirs() creates whole hierarchy of folders
- file.getParentFile() returns File object representing parent folder of file. Also, file.getParent returns parent dir of file as String
- file.list() returns a string array of file names in the dir. list() does NOT throw any checked exceptions
- other methods isDirectory(), isFile(), renameTo(File) - can actually also move a file; they ALL return booleans/success!!!
> FileReader [[ < BufferedReader ; FileWriter < BufferedWriter < PrintWriter ]], all construct from filenamestring or File
- FileReader has int read(char[]) reads the whole file, returns int size read; read() 1 char; read(char[], arroffset, length)
> BufferedReader has methods String readline() - it returns null when all lines have been read. THERE IS NO hasNext method in FileReader(s), only in scanner 
> FileWriter
- constructor(String) will create file on the file system if it does not exist
- constructor(String, boolean append true) will not overwrite the file if it exists, but will append to it
- has write(String) - writes characters to file, has flush() may be called before close; write(char[]/String, offset, length) 
> BufferedWriter - has newLine method.
> PrintWriter - has print(..), println(..), format(..) and printf/format(..)
> System.console() returns the console INSTANCE as java.io.Console, we CAN'T get it with "new"
- method c.readPassword("%s", "pw: ") always reads the password in a char array and without echoing user input
- method c.readLine("%s", "input?: "); contains an element entered by the user (see format)
- methods readPassword and readLine also have non-parameterized versions. The two parameters are actually a printf/format for the message shown before reading
- method c.format("output: %s \n", str); prints something on the screen using format
- methods c.reader() and c.writer() to return associated Reader and Writer
- From Enthuware: You can read as well write ONLY character data from Console.
> Serialization syntax
- FileOutputStream fs = new FileOutputStream("testSer.ser"); ObjectOutputStream os = new ObjectOutputStream(fs);
- os.writeObject(c); os.close();} catch (Exception e)
- FileInputStream fis = new FileInputStream("testSer.ser"); ObjectInputStream ois = new ObjectInputStream(fis);
- c = (Cat) ois.readObject(); ois.close();} catch (Exception e) { e.printStackTrace(); } // CAST OBJECT AT READ!!!
- java.io.NotSerializableException if one non-transient nested object is not serializable
- to custom serialize a field, you declare it at transient!!! then:
- object can define two private methods: private VOID readObject(OIS) and private void writeObject(OOS) // BOTH THROW EX
- inside them you writeInt/writeObject on the stream and before or after call defaultWriteObject() or defaultReadObject()
- keep order of custom written fields in both writeObject(OOS) and readObject(OIS)
- In deserialization, all constructors of the non-serializable superclasses will call. 
- Fields of those non-serializable superclasses will not serialize, unless done manually using writeobj(oos)
- constructors and field initializers + initializers from the first serializable superclass will NOT call

> Regex
- Be careful to use \\ instead of \ to escape java!!! e.g. \\s
- general usage is: Pattern p = Pattern.compile("\\s"); Matcher m=p.matcher("word"); 
  while(m.find()){ syso (m.group()) } next sequence OR
  m.matches() attempts to match whole word with pattern
- you can also use inside find m.start() //indexstart + " " + m.end() // indexafterlast
- "?" means 0 or 1 occurences, "*" 0 or more, "+" 1 or more
- NOTE THAT * is greedy! so .* will match all possible. so "A.*B" will match "ACBAB" in "ACBABC";
  Also note that * will also match empty string!!! so calling find() repeatedly will match empty string and advance 1 char until new match!!!
- group will throw IllegalStateException if find (or match) wasn't called before
- once matched, a group of chars are consumed, and will be skipped for the next find()
- \\d means digit, \\s means space, \\w means word (letters, digits or underscore)
- [^ab] will find any char that is not a or b
- [abcd] will match either char a,b,c or d
- \\b means word boundary, it can be useful to match words delimited by at least one space on either end (e.g. \bsomeword\b)

> Scanner 
- has constructor new Scanner (String), Scanner (File), and ofc inputstream but not discussed
- has methods useDelimiter( STRING not char ) // IT IS NOT SETDELIMITER, BUT USE!!! SCANNER USE DELIMITER
- methods nextInt throw java.util.InputMismatchException if format not ok;
- also has methods next() and nextLine() for reading next token by delimiter, or next line and also boolean hasNext()!!!
- for has methods, they also exist in the form of hasNextBoolean(), hasNextXXX, etc
- ALSO HAS METHOD .findInLine(regexString) that will return the next match!!!

> printf/format("specifiers", "string") are the SAME THING! USED BOTH BY SCANNER AND PRINTWRITER!!!
- SYNTAX IS: %[arg_index$][flags][width][.precision]conversion char
- arg_index$ means which of the argument to be printed at this position
- flags are: 
  - (left justify), 
  + (include a sign), 
  0 (left pad with zeroes, requires spec. width), 
  use def locale group separators (,), 
  ( (enclose neg in paranthesis, does not print sign even if combined with +)
- width is minimum number of chars to print INCLUDING precision, NOT JUST the part before decimal point
- .precision is numbers to print after the decimal point
- conversion acceptable characters are: b, c (char), d (integer), f (floating point), s (string)
- IF CONVERSION FAILS YOU GET IllegalFormatConversionException!!!
- %b will only return false for null and false boolean value, for all other types, including String "false" or 0 it will return true
> printf/format works wrapper objects too! (conversion will be done)
> %f will not accept ints!!! just float and double

> String
- there is no reverse method in the String class.
- there is no append method in the String class. only in StringBuilder/StringBuffer
- only literal strings are automatically added to the pool. two objects pointing there will be equal using ==
- Strings computed at runtime are always NEW strings: like string resulted as ("Hello" + var) where var is a variable
- To add runtime strings to the pool you must use s = s.intern()!!! But until java 7 it is a bad idea and will eventually OutOfMemoryError: PermGen space 
- somestring.replace ("whattoreplace", "replacement") is the correct usage
- string has length() method, array has length property, collections have size() method
- new String("smth") will create 2 objects; one unreferenced literal in the string pool, and a new refed heap String
- String has .split(regexDelimiter) method that tokenizes string into an array of string tokens
- In String.split, all TRAILING delimiters are discarded (not the ones in middle). e.g. "one;;two;;;" => "one", "", "two" (length 3) 
- natural ordering of strings is alphabetical (like in dictionary) and not related to string length
- in this natural ordering: spaces < numbers < Uppercase < Lowercase

------------------------------------------------------------------------------------------
Chapter 7: Generics and Collections
------------------------------------------------------------------------------------------
> You don't specify dimensions when using array initializers. int[] a = new int[2]{1,2} is incorrect.
> You cannot use Generic specifiers defined at class level (like <T>) in static methods. 
- Make it a generic static method separately by using the static <U> getStuff(U u) syntax
> If you don't specify <type> when extending a generic type, it will implicitly use Object!!!
> Generic Interfaces exist!
> Passing a generic collection to a non generic collection method parameter will result in warning ONLY if the method ADDS something
> Passing a non generic collection to a generic collection method parameter will result in warning
> You can't call add on a collection<? extends Something>, which has ?extends wildcard param. Compile error! YOU CAN ON "? super String"!!!!
> you cannot do <T super SomeClass>, but only <? super SomeClass> as the first one will have no sense (it's implicitly left unbounded/Object bounded)
> you can declare a class with a name that is the same as the type parameter placeholder: class X { public <X> X(X x) { } }
> When returning a generic List<? super/extends E> from a method, you can only assign it to List or List<?> or List<same as ret>
> PriorityQueue 
- is NOT a List, it is a Queue
- has (int maxelements, comparator<T>) constructor
- add() and offer() do the same thing; poll removes minimum; peek gets minimum without removing
- provides no non-destructive traversal methods. poll (get head) and remove (from anywhere) are used.
> HashMap
- can have one null key
- values() returns a Collection that does not guarantee any ordering
- HashTable is a legacy synchronized HashMap
> LinkedHashMap maintains insertion order by default BUT
- it has a special constructor LinkedHashMap(int initialcapacity, int loadfactor, boolean lastAccessed) to favor last accessed iteration
> A map cannot contain itself as a key (compiles,but bad practice -mutable key) but can contain itself as a value
> Default ArrayList max elements is 10 when not specified
> Collections utility class
- sort(List) or sort(list, comparator) throw ClassCastException if the elements are not comparable (ml do not implement Comparable)
> Arrays throw ArrayIndexOutOfBoundsException when accesing an element at an index >= size. if size=0 then even a[0]
> Arrays throw ArrayStoreException if we add a Dog into a Cat array through an Animal reference.
> Arrays utility class 
- if the elements are not comparable (ml do not implement Comparable) sort() throws ClassCast exception
- sort(...) has no overload for privitive types that also take a Comparator!!!
- sort(...) alter the objects they get as a parameter! THEY RETURN void (also for lists, not just arrays)
- binarySearch(arr, key [,comparator]) must use the same comparator to return relevant results
- if binarySearch(...) does not find the element it returns -insertionPoint -1 where insertionpoint is indexof first elem > key
> Comparator has int compare(T a, T b) AND Comparable has int compareTo(T other)
> Comparable/Comparator can also be implemented non-generic!!! Then, the parameters will be Object.
> Comparator has static .reverseOrder() method that returns a comparator that imposes reverse natural ordering (usable for natural-order types)
- comparator.reversed() is a non-static method of a comparator instance that can return a new comparator that imposes reverse order of the current one
> list.toArray() returns a NEW array containing elements of the list; it comes with a param version to use specific destination array
> Arrays.asList(array) returns a Collection lively backed up by the specific array. Changes to one update both, unlike toArray result
> AbstractList's removeRange(firstIndexIncl, lastIndexExcl) is PROTECTED. Please use .sublist(f,lexcl).clear() which delegates to removeRange internally.
> TreeSet (methods)
- NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
- SortedSet<E> subSet(E fromElement, E toElement) // like any java range, last element is exclusive, first is inclusive
- SortedSet<E> tailSet(E fromElement) // Returns live view set whose elements >= fromElement. 
- NavigableSet<E> tailSet(E fromElement, boolean inclusive) // ~//~ greater than (or equal to, if inclusive is true) fromElement.
- headSet(E) and headSet(E,b) work exactly the same only headset(E) return elements STRICTLY smaller
- ceiling(E) and floor(E) will return elements greater OR EQUAL, respectively lower or EQUAL to the specified elem or null if not ex
- higher(E) and lower(E) will return elements STRICTLY greater, respectively STRICTLY lower to the specified elem or null if not ex
- first(), last() will return the respective elements.
- descendingSet() will return a reversely sorted TreeSet
- pollFirst(), pollLast() also work returning and also removing the respective elements
- Please note that many of this methods are also available for TreeMap (e.g. firstEntry, ceilingKey, pollLastEntry, descendingMap)
- REMEMBER: if you add an out of range element to a live subSet, you get java.lang.IllegalArgumentException: key out of range
> Treeset will permit adding one first non-comparable-implementing object, and will fail only after adding another one
> constructors CANNOT be synchronized! They don't normally have to because the obj is available only to creating thread 
> Set add will only add element if it's new. (returns false if not new). Map put will overwrite associated value.
> If we extend a genericized<Something> class, keep in mind the type of the extended class are set in place to Something
- Something really tricky here is that false overrides (overloads) of generic class' methods (same name and arity) will FAIL COMPILATION!

------------------------------------------------------------------------------------------
Chapter 8: Inner Classes
------------------------------------------------------------------------------------------
> Only TOP-LEVEL nested classic can be declared static. BUT a static inner class can contain other non-static inner classes
> Inner classes can also be declare private or protected
- Inner classes access modifiers apply independently of the parent class (e.g. package-private inner class in public class)
> When you instantiate inner class you do Outer.Inner inner = outer.new Inner(); // you do not requalify the new part!!!
> When you instantiate static nested class you do Outer.StaticNested staticNested = new Outer.StaticNested(); // both parts 'Outer' qualified
> It is valid that an inner class CAN extend its parent class
> You cannot have an inner class with the same name as its parent
> An inner class has has access to all members of the parent class, including private ones
> You CAN'T have NON-FINAL static declarations inside an inner (non-static) class!!! In a static one you can.
- final static declarations (constants) are ok inside inner classes
> You can't instantiate an inner class like new InnerClass() from a static method of the outer class because there is no <this>
> .this points to the inner class instance. to point to the outer class instance you can use Outer.this
> A mehtod without the abstract modifier in an abstract class will not be abstract MUST define a body. ELSE COMPILER ERROR. It's not like in interfaces!!!
> A method local inner class can be declared abstract OR final, but not any other modifier like public/private, etc
> when creating an anonymous class like A a = new A(){}; the semicolon at the end is needed and ommiting it is a compile error!
> You can only call methods on an annonymous class which the defined reference type knows about (usual thing for non-ann classes)
> An annonymous type can only extend or implement a class, resp. an interface at a time. No way around this!
> An anonymous class cannot be declared static
> An anonymous class is implicitly final
> An anonymous class cannot have constructors
> An anonymous class must respect the constructors of an abstract class and must be declared as new AbstractClass(someparam) {...}
  if the abstract class has no other constructors except de parameterized one. Else, compiler error!
> The syntax for instantiating a static nested class is BigOuter.Nest n = new BigOuter.Nest();

------------------------------------------------------------------------------------------
Chapter 9: Threads
------------------------------------------------------------------------------------------
> The methods that throw InterruptedException are object.wait, Thread.sleep and t.join()
> calling interrupt() will cause an InterruptedException ONLY if the thread on which interrupt() 
  is called, is blocked on an invocation of the wait(...), join(...), or sleep(...), methods of this class
> t.join() will make the current thread wait for t's completion. It can also get a param, t.join(milliseconds),
  which will allow current thread to run after ms elapsed regardless of t's completion
> an outside interrupt will cause a call to isInterrupted inside the target Thread run method to start returning true.	 
> sleep and yield are STATIC. pay attention if they are called on a referenced thread. Only the current is affected!
- sleep and yield can only run on the current thread
> Yield is used to permit other threads of EQUAL PRIORITY to get a change to run
> There is NO lock method. The stop, suspend and resume methods are deprecated and should not be on the exam!!!
> Thread priorities (1-10) are the higher, the more critical (unlike priority queues where lower is urgent).
> Default thread priority is 5 (NORM_PRIORITY) for the main thread, and the INHERITED PARENT PRIORITY for all other threads
> Threads can be started from virtually EVERYWHERE, including init blocks, constructors and inner classes
> Two threads can deadlock if they sync on each other's instances, or synchronize lock two resources in nested reverse order.
- They will not deadlock if only one resource is waited for by both of them; it will eventually become available
- Multiple threads CAN deadlock at once.
- Using yield will not fix deadlock-able code.
> watch out! when a method synchronized but not static and changes a static field IS IS NOT THREAD SAFE. it must be made static!!!
> Methods that read must also be synchronized to make a class thread safe
> Only synchronizing write methods is not enough!, Reading methods must be synchronized as well. Also, on the SAME MONITOR, else NO effect.
> Synchronizing the run method will cause two threads that share the same runnable to not execute in parallel, but one after another
> thread.setDaemon(true) can be called to make a thread daemon BEFORE START. if called after start, IllegalThreadStateException 
> the main thread is NOT a daemon thread and is created by VM
> IllegalThreadStateException will also pop if we attempt to start a Thread twice
> The runnable you pass to a thread is called Target
> The non-overriden method of a plain Thread instance does not do anything
> join, sleep and yield keep the lock aquired by synchronized keyword
- wait(), on the other hand, gives them up!!!
> You call object.wait() inside a syncronized block to put the current thread into a waiting state until other thread calls notify on the object
- it's common that 2 threads that run the same runnable, communicate using this.wait() and this.notify() called directly in the run method.
- NOTE THAT you pretty much can't do that directly using classes that extend thread because you can't start the same thread twice
> You cannot call wait on an object unless you have that object's lock. Else you get IllegalMonitorStateException at RUNTIME
> If synchronized methods complete abruptly, locks ARE released!
> Synchronized methods hold a small overhead even when not called in a multithreaded enviroment

------------------------------------------------------------------------------------------
Chapter 10: Development
------------------------------------------------------------------------------------------
> Command javac Someclass.java SomeOtherClass.java
- cp "path1;path2" can specify directories to scan as classpath roots to resolve classes (.class), in that order. Also: ;win :linux 
- classpath is by default the current directory (excluding clases right here). 
- Make sure you add . if you want to resolve .class (packages) in the current dir IF you also specify other cp folders 
- overriding classpath using -cp or -classpath will REPLACE settings from CLASSPATH env variable
- -d classes specifies where to put the output
- if the specified -d directory does not exist, then no class file will be created!!!
- will create package hierarchy under output dir if compiled class is in a package other than default one
- jars from $JAVA_HOME/jre/lib/ext/*.jar get added to cp automatically; also the ones specified in $CLASSPATH environment variable
- -source 1.3 is the LAST ONE to NOT consider assert a keyword!!! Starting from 1.4 it is a keyword!
> Command jar -cf JarFileName classesdir
- when -f is used file name must follow (not required to end in .jar) 
- META-INF is automatically created. no need to exist before command. It will not contain classes!
- -c means to create new archive, -u to update existing one
- you should not put java files in the META-INF folder. Compiled classes will start from root and not be in this folder
> Command java SomeClass
- -ea is only used for running, not compiling. It is required to enable assertions; 
- -esa is used to enable assertions for system classes
- -dsa disables system assertions
- -ea:possiblyqualified.Class or -ea:somepackage... , (yes with ellipsis) can enable assertions only in certain places
- -da:possiblyqualified.Class or -da:somepackage... may be used for disabling assertions in certain sub-places
- java -cp classes somepackage.Someclass // -cp specifies the classpath root. Someclass in package somepackage will run
- there can be more classpaths, separated by File.pathSeparator (;win, :linux), search stops at first find.
- java.lang.NoClassDefFoundError may arise if the classpath does not include the necessary classes for running the main method
- you can also use full name flags like -disableassertions or -classpath


------------------------------------------------------------------------------------------
Extras / Curiosities
------------------------------------------------------------------------------------------
> Q: Which Set implementation does LinkedHashMap.keySet() use? 
  A: It's NOT LinkedHashSet as you might expect, but HashMap$KeySet (private type).
- It does guarantee order of insertion! It is not sorted!
> If you find a compilation problem and there are other CORRECT statements dependendent on the problematic class
  you only point the FIRST problem, and consider the dependent statements ok! (ex. inherited uncompilable class)
> (Java7) If you call somestring.intern() on a string will add this string to the pool or return the already pooled string
- you usually want to replace the strings with its interned value by doing s = s.intern(). This is to preserve memory.
> Two implemented interfaces have same const & YOU USE IT (only then) => field ambigous compiler error!
> Math.round(float) returns int and Math.round(double) returns long. they may be used to do real rounding (not for printing)
  using something like double x = 100.55; x = x * 100; x = (double) Math.round(x); x = x / 100;
> String "+" operator actually uses stringbuilder.append internally

------------------------------------------------------------------------------------------
To be checked (for in progress exams / curiosities)
------------------------------------------------------------------------------------------