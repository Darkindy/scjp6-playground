------------------------------------------------------------------------------------------
Chapter 1: Declarations and Access Control
------------------------------------------------------------------------------------------
> Integer caches -128 to 127 objects created through any other means than new operator
  (autoboxed literals, Integer.valueOf("")), meaning same object will be returned
- parseInt returns primitive int, valueOf returns wrapper (Integer)
- parseInt, constructor(String) can throw NumberFormatException if string is invalid
> Permitted access modifiers for top level classes are only: public and (package-private)
> Default constructor always inherits access modifier of class
> if you implement an interface you must declare the methods public. leaving them package-private is c. ERROR
> A final class field must always be explicitly initialized inline, in constructor or in initializer
> Interface implicits!!!
- REMEMBER: constants in interfaces are NOT necessary to be declared public static final, but any or none of these (rest of modifiers will be added auto)
- REMEMBER: methods in an interface are NOT necessary to be declared public abstract, but any or none of these (rest of modifiers will be added auto)
- ANY OTHER MODIFIERS like private/protected for the above cases will result in COMPILER ERROR 
> strictfp can be applied to methods, classes and interfaces
> If a class is not public (say package-private), its public variables will NOT be available to ANY class (in this case, only to classes in the package) 

------------------------------------------------------------------------------------------
Chapter 2: Object Orientation
------------------------------------------------------------------------------------------
> you cannot hide a method using static method in the derived class! 
- the reverse is also true; you also cannot hide a static method using a method.
> In order to override, the parameters of the derived method should be exactly the same. (Parameter type invariance)
- Covariant (more derived) or contravariant (ancestor type) parameters are NOT valid overrides, BUT LEGAL OVERLOADS!!!
- Covariant return types are permitted!
- Legal signature of equals is always: public boolean equals(Object other); you cannot use class type as parameter
> super and this cannot be used from a static context (like main)
> You CAN'T do "this.super" or "var.super"
> No comma (,) between extends and implements. Comma is used only to separate multiple interfaces
> No multiple use of implements keyword. Use comma for multiple interfaces
> An interface can extend multiple other interfaces
> Interface methods CAN declare exceptions!
> It's a compiler error to assign a new Base object to a derived reference. If you cast => ClassCastExc at runtime
> Finalize
- You can call finalize by hand BUT it acts just as a simple method call (no special meaning)
- GC will only run finalize once (it remebers this)
- Objects can be saved from GC during finalization. The next time object is gc, finalize will not be called.
> Default equals = equal objects by memory address, default hashcode = memory address casted to int
> Default hashCode and equals are legal implementations, but hard to use. Overriding identical behavior is ok.
> IF a.equals(b) then a.hashCode() == b.hashCode(). If you override equals then you must override hashcode!
> By hashcode you identify the bucket (reducing time), then by equals you iterate to really find the object/key
> If a base class has a parameterized constructor, derivatives need to invoke it.
- It is valid that subclass can indirectly invoke the base parameterized constructor through another of its
  constructors, that call super(...) as it's first statement.
> BE CAREFUL of private constructors/method calls in the same class as the main method! they work!

------------------------------------------------------------------------------------------
Chapter 3: Assignments
------------------------------------------------------------------------------------------
> Widening is preferred to boxing
> Varargs must be last argument
> Varargs are always considered last in overloading, even when we also have (Object) sgntr
> You can't widen then box, but you can box then widen! REMEMBER FIRST you BOX!!!
- e.g. you CAN int -> Integer -> Object (assigning to superclass is considered widening in wrappers)
- but you can't short -> long -> Long
- Integer (wrapper) increment and postincrement WORK! they really assign the value (create new obj).
> always think x+=y as x = (t) (x + y) and x++ as x = (t) (x+1)
> Boolean.valueOf or the constructor(String) of boolean returns true for a case insensitive tRuE, else false, never null

------------------------------------------------------------------------------------------
Chapter 4: Operators
------------------------------------------------------------------------------------------
> You can use logical or (xor) "^" to return true from mixing two different valued booleans
> << and >>> are actually the opposites. >> keeps sign bit, >>> has more force and pulls it
> Correct syntax is a instanceof ClassNameOnly-NotAVariableNotAnExpression. NO PARANTHESIS~~!
- it will return true if a is a ClassNameOnly (or a subclass of it).

------------------------------------------------------------------------------------------
Chapter 5: Flow Control, Exceptions, and Assertions
------------------------------------------------------------------------------------------
> Assertions should gen. be used to validate private method args. Validating public input is inappropriate (e.g. args of main)
- Assertions like "assert false" are appropriate to use in any method to mark a location where code should not reach.
- asserting a false statement throws AssertionError => program exits unless the error is caught
- asserting a modifying statement is bad practice. code will only modify is assertions are enabled.
- syntax is assert boolean_statement : non_void_return_statement where the 2nd will print to screen (usually a string)
- the 2nd expression can call modifiable code, but usually it doesn't matter anymore as the program doesn't catch the error and exits
> while(false) and for(;false;) are illegal. if(false) and do{}while(false)are legal!!
- for if(true) throw RuntimeException, any code following will NOT be considered UNREACHABLE! WHAT A HACK! :O
> for(int a = 0, b = 4 ; ; expression(), expression2()) is the correct syntax
- multiple declared variables are permitted but only of the SAME type.
- redefinition of other variables from the parent scope is illegal and is a tricky exam catch!!
- WATCH OUT FOR reusing FOR incrementing variables after closing the for scope!!! => Compile error!
- multiple incrementing expressions are permitted, and they don't have to necessarily increment
> You can add a throws declaration for any checked exception, even though it is not really thrown anywhere
> Order of caught exception MUST be from narrower to broader!!! else COMPILE ERROR!
> in switch it's "default:" not "case default:"

------------------------------------------------------------------------------------------
Chapter 6: Strings, I/O, Formatting and Parsing (API)
------------------------------------------------------------------------------------------
> To get -D passed properties you do: System.getProperty("x") or System.getProperties().getProperty("x")
- you use System.getenv("var"); [ yes with non capital env ] to a an environment variable
> DateFormat has method format(java.util.Date) that returns a formatted date String
- df.parse("string") will throw checked exception ParseException!!! treat it!
> Regex
- general usage is: Pattern p = Pattern.compile("\\s"); Matcher m=p.matcher("word"); 
  while(m.find()){ syso (m.group() + " ")} next sequence OR
  m.matches() attempts to match whole word with pattern
> "?" means 0 or 1 occurences, "*" 0 or more, "+" 1 or more
- group will throw IllegalStateException if find (or match) wasn't called before
> String
- only literal strings are automatically added to the pool. two objects pointing there will be equal using ==
- somestring.replace ("whattoreplace", "replacement") is the correct usage
- string has length() method, array has length property, collections have size() method
- new String("smth") will create 2 objects; one unreferenced literal in the string pool, and a new refed heap String
> StringBuilder
- notable methods: append(String), insert(int,String), reverse(), delete(startIncl, end), toString()
- replace(...) with 2 args(what,withwhat) or 3 args(first,lastNotIncl,withwhat)
> MOST FILE OPERATIONS THROW EXCEPTIONS
> File
- constructors (string) or (File directory, String)
- has methods exists(); createNewFile() - which really creates,equals then updated returns true if created;
- file cannot be closed, only readers and writers do
- Directories. You can use the following methods on File: boolean mkdir()
- file.list() returns a string array of file names in the dir. list() does NOT throw any checked exceptions
- other methods isDirectory(), isFile(), renameTo(File) - can actually also move a file
> FileReader [[ < BufferedReader ; FileWriter < BufferedWriter < PrintWriter ]], all construct from filenamestring or File
- FileReader has int read(char[]) reads the whole file, returns int size read; read() 1 char; read(char[], arroffset, length)
> BufferedReader has methods String readline() - it returns null when all lines have been read. THERE IS NO hasNext method in FileReader(s), only in scanner 
> FileWriter
- has write(String) - writes characters to file, has flush() may be called before close; write(char[]/String, offset, length) 
> BufferedWriter - has newLine method.
> PrintWriter - has print(..), println(..), format(..) and printf/format(..)
> System.console() returns the console INSTANCE as java.io.Console, we CAN'T get it with "new"
- method c.readPassword("%s", "pw: ") always reads the password in a char array and without echoing user input
- method c.readLine("%s", "input?: "); contains an element entered by the user (see format)
- method c.format("output: %s \n", str); prints something on the screen using format
> Scanner 
- has constructor new Scanner (String), Scanner (File), and ofc inputstream but not discussed
- has methods useDelimiter( STRING not char )
- methods nextInt throw java.util.InputMismatchException if format not ok;
- also has methods next() and nextLine() for reading next token by delimiter, or next line and also boolean hasNext()!!!
> Serialization syntax
- FileOutputStream fs = new FileOutputStream("testSer.ser"); ObjectOutputStream os = new ObjectOutputStream(fs);
- os.writeObject(c); os.close();} catch (Exception e)
- FileInputStream fis = new FileInputStream("testSer.ser"); ObjectInputStream ois = new ObjectInputStream(fis);
- c = (Cat) ois.readObject(); ois.close();} catch (Exception e) { e.printStackTrace(); } // CAST OBJECT AT READ!!!
- java.io.NotSerializableException if one non-transient nested object is not serializable
- to custom serialize a field, you declare it at transient!!! then:
- object can define two private methods: private VOID readObject(OIS) and private void writeObject(OOS) // BOTH THROW EX
- inside them you writeInt/writeObject on the stream and before or after call defaultWriteObject() or defaultReadObject()
- keep order of custom written fields in both writeObject(OOS) and readObject(OIS)
- In deserialization, all constructors of the non-serializable superclasses will call. 
- Fields of those non-serializable superclasses will not serialize, unless done manually using writeobj(oos)
- constructors and field initializers + initializers from the first serializable superclass will NOT call

------------------------------------------------------------------------------------------
Chapter 7: Generics and Collections
------------------------------------------------------------------------------------------
> You don't specify dimensions when using array initializers. int[] a = new int[2]{1,2} is incorrect.
> You cannot use Generic specifiers defined at class level (like <T>) in static methods. 
- Make it a generic static method separately by using the static <U> getStuff(U u) syntax
> PriorityQueue 
- is NOT a List, it is a Queue
- has (int maxelements, comparator<T>) constructor
- add() and offer() do the same thing; poll removes minimum; peek gets minimum without removing
- provides no non-destructive traversal methods. poll (get head) and remove (from anywhere) are used.
> HashMap
- can have one null key
- values() returns a Collection that does not guarantee any ordering
> Default ArrayList max elements is 10 when not specified
> Collections utility class
- sort(List) or sort(list, comparator) throw ClassCastException if the elements are not comparable (ml do not implement Comparable)
> Arrays throw ArrayIndexOutOfBoundsException when accesing an element at an index >= size. if size=0 then even a[0]
> Arrays utility class if the elements are not comparable (ml do not implement Comparable)
- sort() throws ClassCast exception of 
- binarySearch(arr, key [,comparator]) must use the same comparator to return relevant results
- if binarySearch(...) does not find the element it returns -insertionPoint -1 where insertionpoint is indexof first elem > key
> Comparator has int compare(T a, T b) AND Comparable has int compareTo(T other)
> AbstractList's removeRange(firstIndexIncl, lastIndexExcl) is PROTECTED. Please use .sublist(f,lexcl).clear() which delegates to removeRange internally.
> TreeSet (methods)
- NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
- SortedSet<E> subSet(E fromElement, E toElement) // like any java range, last element is exclusive, first is inclusive
- SortedSet<E> tailSet(E fromElement) // Returns live view set whose elements >= fromElement. 
- NavigableSet<E> tailSet(E fromElement, boolean inclusive) // ~//~ greater than (or equal to, if inclusive is true) fromElement.
- headSet(E) and headSet(E,b) work exactly the same only headset(E) return elements STRICTLY smaller
- other notable methods: TO BE CONTINUED
- REMEMBER: if you add an out of range element to a live subSet, you get java.lang.IllegalArgumentException: key out of range
> You can't call add on a collection<? extends Something>, which has ? wildcard param. Compile error!
> Array let's you get away with putting a Cat in an Animal array reference which references a Dog array object.

------------------------------------------------------------------------------------------
Chapter 8: Inner Classes
------------------------------------------------------------------------------------------
> Inner classes can also be declare private or protected
- Inner classes access modifiers apply independently of the parent class (e.g. package-private inner class in public class)
> When you instantiate inner class you do Outer.Inner inner = outer.new Inner(); // you do not requalify the new part!!!
> When you instantiate static nested class you do Outer.StaticNested staticNested = new Outer.StaticNested(); // both parts 'Outer' qualified

------------------------------------------------------------------------------------------
Chapter 9: Threads
------------------------------------------------------------------------------------------
> The methods that throw InterruptedException are object.wait, Thread.sleep and t.join()
> sleep and yield are STATIC. pay attention if they are called on a referenced thread. Only the current is affected!
> Thread priorities (1-10) are the higher, the more critical (unlike priority queues where lower is urgent).
> Child thread inherits parent's priority
> Default thread priority is 5
> Threads can be started from virtually EVERYWHERE, including init blocks, constructors and inner classes
> Two threads can deadlock if they sync on each other's instances, or synchronize lock two resources in nested reverse order.
- They will not deadlock if only one resource is waited for by both of them; it will eventually become available
- Multiple threads CAN deadlock at once.
- Using yield will not fix deadlock-able code.

------------------------------------------------------------------------------------------
Chapter 10: Development
------------------------------------------------------------------------------------------
> Command javac Someclass.java SomeOtherClass.java
- cp "path1;path2" can specify directories to scan as classpath roots to resolve classes (.class), in that order. Also: ;win :linux 
- classpath is by default the current directory. Make sure you add . if you redefine this and want to resolve .class in current dir.
- -d classes specifies where to put the output
- will create package hierarchy under output dir if compiled class is in a package other than default one
- jars from $JAVA_HOME/jre/lib/ext/*.jar get added to cp automatically; also the ones specified in $CLASSPATH environment variable
- -source 1.3 is the LAST ONE to NOT consider assert a keyword!!! Starting from 1.4 it is a keyword!
> Command jar -cf JarFileName classesdir
- when -f is used file name must follow (not required to end in .jar) 
- META-INF is automatically created. no need to exist before command. It will not contain classes!
- -x means to create new archive, -u to update existing one
- you should not put java files in the META-INF folder. Compiled classes will start from root and not be in this folder
> Command java SomeClass
- -ea is only used for running, not compiling. It is required to enable assertions
- -ea:possiblyqualified.Class or -ea:somepackage... , (yes with ellipsis) can enable assertions only in certain places
- java -cp classes somepackage.Someclass // -cp specifies the classpath root. Someclass in package somepackage will run
- there can be more classpaths, separated by File.pathSeparator (;win, :linux), search stops at first find.


------------------------------------------------------------------------------------------
Extras / Curiosities
------------------------------------------------------------------------------------------
> Q: Which Set implementation does LinkedHashMap.keySet() use? 
  A: It's NOT LinkedHashSet as you might expect, but HashMap$KeySet (private type).
- It does guarantee order of insertion! It is not sorted!
> If you find a compilation problem and there are other CORRECT statements dependendent on the problematic class
  you only point the FIRST problem, and consider the dependent statements ok! (ex. inherited uncompilable class)
> (Java7) If you call somestring.intern() on a string will add this string to the pool or return the already pooled string