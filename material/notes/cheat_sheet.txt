------------------------------------------------------------------------------------------
Chapter 1: Declarations and Access Control
------------------------------------------------------------------------------------------
> short is always -32768 to 32767. It is NOT platform dependent.
> Integer caches -128 to 127 objects created through any other means than new operator
  (autoboxed literals, Integer.valueOf("")), meaning same object will be returned
> Void is not a wrapper class. The only ones are: Byte, Short, Integer, Long, Float, Double, Character and Boolean
> bool is not a keyword!!! boolean IS the type you want
> NULL is not a keyword. Only lowercase null is. This rule can be applied to any keyword.
> A java identifier cannot start with a digit (be it class, method, variable, etc.)
- _ and $ are valid at any position!
- parseInt returns primitive int, valueOf returns wrapper (Integer)
- parseInt, constructor(String) can throw NumberFormatException if string is invalid
> Permitted access modifiers for top level classes are only: public and (package-private)
> Default constructor always inherits access modifier of class
> if you implement an interface you must declare the methods public. leaving them package-private is c. ERROR
> A final class field must always be explicitly initialized inline, in constructor or in initializer
> Interface implicits!!!
- REMEMBER: constants in interfaces are NOT necessary to be declared public static final, but any or none of these (rest of modifiers will be added auto)
- REMEMBER: methods in an interface are NOT necessary to be declared public abstract, but any or none of these (rest of modifiers will be added auto)
- ANY OTHER MODIFIERS like private/protected for the above cases will result in COMPILER ERROR 
> strictfp can be applied to methods, classes and interfaces
> If a class is not public (say package-private), its public variables will NOT be available to ANY class (in this case, only to classes in the package) 
> Local (method) variables are also called automatic variables
> abstract method cannot be native
> native methods may be used for computationally intensive jobs, acces to drivers, legacy apps written in other langs
> a protected variable of the base class will still not be accessible from a Base parameter of a method in a derived class
  motive is that The Derived class is not involved in the implementation of the base class.
- using a parameter of derived type will correctly give access to the base class field (because it participates in impl)
> there is no such thing as unsigned in Java
> static initializer of class which is not actively used (Just a reference of it set to null for example) will NOT be called
> If the signature of the main method is not valid and we try to run the class using "java", we get java.lang.NoSuchMethodError! Note that the class compiled.
> Java does NOT support chained initialization declaration like: int a = b = c = 100;
- it does however allow it outside initialization (by chaining the operator = which returns the assigned value);
> In an array declaration, the expression from the left of the [ is fully evaluated before the expression in the brackets!!! 
- that's why a[(a=b)[1]] will still refer to elements in the old a
> You can create an array of length 0
> Native methods don't specify a body, else compiler error; also, keep in mind that they can be declared in non-abstract classes
> you CAN declare a static field as transient even though it doesn't make much sense
> Multidimensional array initialization must specify the dimension starting from at least the first bracket. e.g. int[][] a = new int [3][];
- specifying dimensions for the other (more to the right) dimensions is only possible if the first ones are specified
> Integer or Long wrapper classes have .toBinaryString, toHexString and toOctalString() methods
- also Integer and Long wrapper classes have toString(int/long, radix) static methods to output the numbers in other radixes
> unboxing is prefered when doing == between a primitive and a wrapper. 
- you should watch out for NullPointerException though if the wrapper is null

------------------------------------------------------------------------------------------
Chapter 2: Object Orientation
------------------------------------------------------------------------------------------
> order of initialization is: static fields+initializers in the order declared, inline declarations+initializers i.o.d, constructor
- if the used class extends another class the statics of that class will run first
- the inline field initializations+initializer blocks will run AFTER the superclass constructor and before the current class Constructor
  so the superclass' ones will always run first.
> It is legal for ANY class to refer to this also as ClassName.this
> you cannot hide a method using static method in the derived class! 
- the reverse is also true; you also cannot hide a static method using a method.
> In order to override, the parameters of the derived method should be exactly the same. (Parameter type invariance)
- Covariant (more derived) or contravariant (ancestor type) parameters are NOT valid overrides, BUT LEGAL OVERLOADS!!!
- Covariant return types are permitted but only for objects! NOT FOR PRIMITIVES.
- Legal signature of equals is always: public boolean equals(Object other); you cannot use class type as parameter
> super and this cannot be used from a static context (like main)
> You CAN'T do "this.super" or "var.super"
> You CAN'T call super-superclass's method if it was overriden by superclass!!!
> No comma (,) between extends and implements. Comma is used only to separate multiple interfaces
> No multiple use of implements keyword. Use comma for multiple interfaces
> An interface can extend multiple other interfaces
> Interface methods CAN declare exceptions!
> It's a compiler error to assign a new Base object to a derived reference. If you cast => ClassCastExc at runtime
> Finalize
- You can call finalize by hand BUT it acts just as a simple method call (no special meaning)
- GC will only run finalize once (it remebers this)
- Objects can be saved from GC during finalization. The next time object is gc, finalize will not be called.
> Default equals = equal objects by memory address, default hashcode = memory address casted to int
> Default hashCode and equals are legal implementations, but hard to use. Overriding identical behavior is ok.
> IF a.equals(b) then a.hashCode() == b.hashCode(). If you override equals then you must override hashcode!
> By hashcode you identify the bucket (reducing time), then by equals you iterate to really find the object/key
> If a base class has a parameterized constructor, derivatives need to invoke it.
- It is valid that subclass can indirectly invoke the base parameterized constructor through another of its
  constructors, that call super(...) as it's first statement.
> BE CAREFUL of private constructors/method calls in the same class as the main method! they work!
> Strings declared inside a block/method will NOT be available for garbage collection (in java 6 anyway) after the method/block ends
> Objects that have references to them might still be garbage collected if those references are from objects also g.c. eligible (islands)
> You can ask for gc by either using System.gc() or Runtime.getRuntime().gc()
> Finally is not guaranteed to run, for example if you call System.exit(0) it won't run
> The only guaranteed thing about gc may be that if you are getting close to filling the memory the gc will run
> No mechanisms will force a right-here-right-now garbage collection!!!
> When declaring enums, there must always be a ";" after the enum values if class code follows
- this applies even if the last enum value overrides a method and ends with }. This means }; is correct.
- Quick note: the other known case where ; follows } is when declaring an ANONYMOUS (not named-local) class AND assigning it to a reference!!!
> A is-like-a I usually means A implements I so A can be used for all purposes like an I 

------------------------------------------------------------------------------------------
Chapter 3: Assignments
------------------------------------------------------------------------------------------
> Order of signature matching:
- Phase 1: Identify Matching Arity Methods Applicable by widening (ignores varargs and boxing/unboxing)
- Phase 2: Identify Matching Arity Methods Applicable by Method Invocation Conversion (ignores varargs, respects boxing/unboxing)
- Phase 3: Identify Applicable Variable Arity Methods
> So, widening is preferred to boxing and when an exact match isn't found, the JVM uses the method with the smallest argument that is wider
> You can't widen then box, but you can box/unbox then widen! REMEMBER FIRST you BOX!!!
> Varargs must be last argument
> Varargs are always considered last in overloading, even when we also have (Object) sgntr
> When you get to phase 3 (varargs) you can use boxing / widening also and the vararg method chosen will ofc prefer widening vararg over boxing vararg
- e.g. you CAN int -> Integer -> Object (assigning to superclass is considered widening in wrappers)
- but you can't short -> long -> Long
- Integer (wrapper) increment and postincrement WORK! they really assign the value (create new obj).
> always think x+=y as x = (t) (x + y) and x++ as x = (t) (x+1)
> Boolean.valueOf or the constructor(String) of boolean returns true for a case insensitive tRuE, else false, never null. BUT NullPointerException if parameter is null
> something like a [ (a=b) [k] ] where a and b are arrays will make a [...] still refer to the original a, and not b!!!
> new Short(9) is not ok, because 9 is considered an int. EXPLICIT cast is needed new Short((short) 9); applies to other as well
> dividing two floats and then multiplying the result to get to the initial float WORKS! THE SAME IS NOT TRUE FOR DOUBLES due to higher precision.
- e.g. float f = 1.0F / 3.0F; syso(f* 3.0F == 1.0F) will return true!
> Java performs implicit narrowing conversions of primitives when the context requires it when the value is the result of a constant expression only
> a char can always be assigned to an int. 
> The reverse is true only for compile-time constants (inline literal initialization) if the int is between 0 and 65535 (unsigned short)
- ints only upto 65565 - which is short maxvalue will cast directly to char; higher ints will give compile error.
> THE RULE IS that for compile time constants, int can be automatically inline assigned to: 
  byte (-128 to 127), short(-32768 to 32767), char (0 to 65535)
> For dynamic (non-compile-time-constant) primitive conversion that narrows, an explicit cast is needed as in any narrowing
- that means that char c = a * b where a and b are ints will not work because it's a runtime determined value!!!
> for hex values, you can declare them Case Insensitive: 0XDeadCafe
> valid suffixes (Case Insensitive) are: L (long), F (float), D (double). F is needed to initialize a float literal because double is default!!! e.g. float f = 1.0; => ERROR
- they can be applied also to oktal or hex numbers
- THERE IS NO BINARY LITERAL IN JAVA 6. only in 7+: 0b11 = 3. FORGET USING IT!!!
> Comma CANNOT be used in integer literals - you might think as thousands separator. => Compiler error
> char d = (char) -98; is RIDICULOUS, but LEGAL;  the cast is needed as the number isn't between 0 and 65535
> any operation involving anything int-sized or smaller is always an int. e.g. byte * short
- any operation involving anything int-sized or smaller is always a long. e.g. char * long (YES, CHAR CAN BE USED IN ARITHMETHICS, just like a number)
- any operation involving float or smaller is always a float.
- any operation involving double is always a double!
> The unary minus operator (negation), or the unary plus operator (no effect) applied to a short results in an int. Same rules as above also apply! BE CAREFUL!  
> when printing floats/doubles (especially ones casted from integer values), they always print at least one 0 decimal. e.g. (double) 1L prints 1.0
> In 2's complement: 
- to find out the value of a negative number using two's complement notation, you flip all of the bits and then add 1.
- the reverse it also true! To get from 5 to -5 you flip the bits of 5 and add one.
- For somevar = Integer.MIN_VALUE, -somevar (minus somevar) will be == to somevar, which is Integer.MIN_VALUE!!! this happens only for MIN_VALUE for reason of 2's complement
> For assigning references, you can assign a subclass of the declared type, but not a superclass of the declared type
> All the numeric wrapper classes have .floatValue, .intValue, .shortValue, etc. to convert any numeric type to any other numeric primitive type

------------------------------------------------------------------------------------------
Chapter 4: Operators
------------------------------------------------------------------------------------------
> Compound assignment operators like *= evaluate the right expression first. e.g.: a * = b + c is in fact a = a * (b + c)
> You can compare a character to any number, including floats/doubles
> if a float 1.0 and an int 1 are considered equal. Similar things apply for other primitives equality
> You can't compare anything with anything like int with Object
> the assignment operator (=) has the lest precedence. left, then right members will be fully evaluated first.
> You can use logical or (xor) "^" to return true from mixing two different valued booleans
> << and >>> are actually the opposites. >> keeps sign bit, >>> has more force and pulls it
> Correct syntax is a instanceof ClassNameOnly-NotAVariableNotAnExpression. NO PARANTHESIS~~!
- it will return true if a is a ClassNameOnly (or a subclass of it).
- ATTENTION: instanceof will give compiler error if right member Class is not assignable from the left member class
- instanceof inside base class constructor will know that it is a whether class being constructed and it will return true if so
- a null check is NOT required when calling instanceof
> ~ only applies to ints (bitwise not)
> *, / and % all have the same level of precedence
> All NaNs (like Float.NaN) are incomparable, returning false when compared with == either as primitive or object
- yes indeed you can assign Float.NaN to a primitive. It is not a real number (it cannot be compared) and will print NaN. Any operations on it will also result in NaN.
- f.equals(g) will return true if both f and g are Float.NaN. This is THE ONE exception of equals of Floats!
- The other is that if a Float representing 0.0f and the other -0.0f will be false when applying equals(), even though == on their .floatValue()s will be true
- there is no Integer.NaN or Long.NaN

------------------------------------------------------------------------------------------
Chapter 5: Flow Control, Exceptions, and Assertions
------------------------------------------------------------------------------------------
> you can call instance methods in inline field initialization, and they will use the state variables initialized until reaching the current var initialization
- for inline initialized variables after the current initialization, it will not know about this and will use default values (0 / null)
> you can label: { } block, and IT IS LEGAL TO do break label; from a loop inside this block and it will go the the end of the block  
> Assertions should gen. be used to validate private method args. Validating public input is inappropriate (e.g. args of main)
- Assertions like "assert false" are appropriate to use in any method to mark a location where code should not reach.
- asserting a false statement throws AssertionError => program exits unless the error is caught
- asserting a modifying statement is bad practice. code will only modify is assertions are enabled.
- syntax is assert boolean_statement : non_void_return_statement where the 2nd will print to screen (usually a string)
- the 2nd expression can call modifiable code, but usually it doesn't matter anymore as the program doesn't catch the error and exits
> while(false) and for(;false;) are illegal. if(false) and do{}while(false)are legal!!
- for if(true) throw RuntimeException, any code following will NOT be considered UNREACHABLE! WHAT A HACK! :O
> for(int a = 0, b = 4 ; ; expression(), expression2()) is the correct syntax
- multiple declared variables are permitted but only of the SAME type.
- redefinition of other variables from the parent scope is illegal and is a tricky exam catch!!
- WATCH OUT FOR reusing FOR incrementing variables after closing the for scope!!! => Compile error!
- multiple incrementing expressions are permitted, and they don't have to necessarily increment
> You can add a throws declaration for any checked exception, even though it is not really thrown anywhere
> Order of caught exception MUST be from narrower to broader!!! else COMPILE ERROR!
> When you throw exceptions from the finally block, any exceptions thrown in the try are FORGOTTEN and only the finally one propagates!
> in switch it's "default:" not "case default:"
> a SWITCH with no case (an empty switch) IS OKAY (COMPILABLE)
> a SWITCH cannot have any other declarations before a label. a label must be the first instruction inside it
> variables declared in previous switch cases are reusable even after break
- they however MUST be reinitialized explicitly in each case (even if a break was not used in the declaring case)
> You CANNOT use a previously declared variable e.g. "o" in a for each loop, example for(o : c) { }
> You CAN use a final modifier on a foreach loop (only FOREACH, not for), example for (final Object o : c) { }
> throwing null/Null exception is legal compilation but will result in NullPointerException at runtime.

------------------------------------------------------------------------------------------
Chapter 6: Strings, I/O, Formatting and Parsing (API)
------------------------------------------------------------------------------------------
> java.util.Date is NOT immutable; it uses alterable epoch time
- Date(long milliseconds) is a valid constructor
- you can use getTime() to get the long value of milliseconds
- you can use setTime(long milliseconds) to modify the current date to other milliseconds value!!! 

> java.util.Calendar
- you obtain it using Calendar.getInstance();
- you can set date to it using calendar.setTime(date)
- you can also use calendar.set(year, month, day) BUT REMEMBER MONTH STARTS AT 0 (ZERO) or you could use Calendar.JANUARY
- c.add(Calendar.HOUR, 1) or c.roll(Calendar.MONTH, 11) works; roll is like add only it leaves larger units as it and recycles through specified unit
- c.get(Calendar.DAY_OF_MONTH) returns day of month(e.g.31); you don't have to know all fields for exam
- c.set(Calendar.MONTH,0) sets the month to January
- calendar.getTime() obtains a Date represented by this calendar

> java.text.DateFormat
- BOTH DateFormat and NumberFormat CAN ONLY set LOCALE at the moment of instantiation!!! The is NO METHOD TO CHANGE IT AFTERWARDS
- DateFormat.getDateInstance(), DateFormat.getDateInstance(int DateFormat.LONG) return date formats for default locale
- DateFormat.getDateInstance(int DateFormat.LONG, locale); will get a Dateformat object for that
- same for DateFormat.getTimeInstance(...), they still use the following int DateFormat.* constants for time formats (please infer)
- getDateTimeInstance(...) also exists and it's the only one that retains time!!!
- SHORT = 12.13.52, MEDIUM (default for getDATEInstance() = Jan 12, 1952, LONG = January 12, 1952, FULL = Tuesday, April 12, 1952 AD
- DateFormat.getInstance() exist... but without params, uses SHORT for both date and time formatting! not used frequently
- df.parse("string") will return a Date and will throw checked exception ParseException!!! treat it!
- df.format(java.util.Date) that returns a formatted date String

> java.text.NumberFormat
- NumberFormat.getInstance(locale) gets number formatter for specific locale
- NumberFormat.getCurrencyInstance(locale) gets number formatter for specific locale; curiosity: f.setCurrency(Currency.getInstance("EUR")) can further set currency
- NumberFormat.getPercentInstance(locale) also exists.
- There are methods .getInstance() and .getCurrencyInstance() - and will use current locale
- nf.parse returns a Number, the kind of what it has parsed
- you can use nf.setParseIntegerOnly(true) to only further consider integer parts of floating point number strings
- nf.format(Number) that returns a formatted number String; throws arithmetic exc if roundingmode is set to unnecessary
- nf.setRoundingMode(RoundingMode) can set rounding mode; IF NOT SPECIFIED IS HALF_EVEN. round up usually, unless 0.5 then round to nearest EVEN number
- nf.setMaximumFractionDigits and nf.setMinimumFractionDigits will be respected, ROUNDING WILL BE APPLIED when using format(...)

> java.util.Locale
- getDefault() gets current default locale!!! remember JUST getDefault()!!!
- new Locale(language); or Locale(language, country);
- example new Locale("it","CH"); // Switzerland
- you can also use Locale.CANADA constants for some important countries
- there are also methods loc.getDisplayCountry() and loc.getDisplayLanguage() that will return the name of country/language in cur locale (english)
- to return the name of country/language in other locales, you can use the parameterized versions like getDisplayLanguage(otherLocale) 

> To get -D passed properties you do: System.getProperty("x") or System.getProperties().getProperty("x")
- you use System.getenv("var"); [ yes with non capital env ] to a an environment variable

> StringBuilder
- notable methods: append(String), insert(int,String), reverse(), delete(startIncl, end), toString()
- replace(...) with 2 args(what,withwhat) or 3 args(first,lastNotIncl,withwhat)
- is only available from java 1.5 onward
> MOST FILE OPERATIONS THROW EXCEPTIONS
> File
- constructors (string) or (File directory, String)
- has methods exists(); createNewFile() - which really creates,equals then updated returns true if created;
- file cannot be closed, only readers and writers do
- Directories. You can use the following methods on File: boolean mkdir()
- file.list() returns a string array of file names in the dir. list() does NOT throw any checked exceptions
- other methods isDirectory(), isFile(), renameTo(File) - can actually also move a file; they ALL return booleans/success!!!
> FileReader [[ < BufferedReader ; FileWriter < BufferedWriter < PrintWriter ]], all construct from filenamestring or File
- FileReader has int read(char[]) reads the whole file, returns int size read; read() 1 char; read(char[], arroffset, length)
> BufferedReader has methods String readline() - it returns null when all lines have been read. THERE IS NO hasNext method in FileReader(s), only in scanner 
> FileWriter
- has write(String) - writes characters to file, has flush() may be called before close; write(char[]/String, offset, length) 
> BufferedWriter - has newLine method.
> PrintWriter - has print(..), println(..), format(..) and printf/format(..)
> System.console() returns the console INSTANCE as java.io.Console, we CAN'T get it with "new"
- method c.readPassword("%s", "pw: ") always reads the password in a char array and without echoing user input
- method c.readLine("%s", "input?: "); contains an element entered by the user (see format)
- methods readPassword and readLine also have non-parameterized versions. The two parameters are actually a printf/format for the message shown before reading
- method c.format("output: %s \n", str); prints something on the screen using format
- methods c.reader() and c.writer() to return associated Reader and Writer
- From Enthuware: You can read as well write ONLY character data from Console.
> Serialization syntax
- FileOutputStream fs = new FileOutputStream("testSer.ser"); ObjectOutputStream os = new ObjectOutputStream(fs);
- os.writeObject(c); os.close();} catch (Exception e)
- FileInputStream fis = new FileInputStream("testSer.ser"); ObjectInputStream ois = new ObjectInputStream(fis);
- c = (Cat) ois.readObject(); ois.close();} catch (Exception e) { e.printStackTrace(); } // CAST OBJECT AT READ!!!
- java.io.NotSerializableException if one non-transient nested object is not serializable
- to custom serialize a field, you declare it at transient!!! then:
- object can define two private methods: private VOID readObject(OIS) and private void writeObject(OOS) // BOTH THROW EX
- inside them you writeInt/writeObject on the stream and before or after call defaultWriteObject() or defaultReadObject()
- keep order of custom written fields in both writeObject(OOS) and readObject(OIS)
- In deserialization, all constructors of the non-serializable superclasses will call. 
- Fields of those non-serializable superclasses will not serialize, unless done manually using writeobj(oos)
- constructors and field initializers + initializers from the first serializable superclass will NOT call

> Regex
- general usage is: Pattern p = Pattern.compile("\\s"); Matcher m=p.matcher("word"); 
  while(m.find()){ syso (m.group()) } next sequence OR
  m.matches() attempts to match whole word with pattern
- you can also use inside find m.start() //indexstart + " " + m.end() // indexafterlast
- "?" means 0 or 1 occurences, "*" 0 or more, "+" 1 or more
- group will throw IllegalStateException if find (or match) wasn't called before
- once matched, a group of chars are consumed, and will be skipped for the next find()
- \\d means digit, \\s means space, \\w means word (letters, digits or underscore)
- [^ab] will find any char that is not a or b
- \\b means word boundary, it can be useful to match words delimited by at least one space on either end (e.g. \bsomeword\b)

> Scanner 
- has constructor new Scanner (String), Scanner (File), and ofc inputstream but not discussed
- has methods useDelimiter( STRING not char ) // IT IS NOT SETDELIMITER, BUT USE!!! SCANNER USE DELIMITER
- methods nextInt throw java.util.InputMismatchException if format not ok;
- also has methods next() and nextLine() for reading next token by delimiter, or next line and also boolean hasNext()!!!
- for has methods, they also exist in the form of hasNextBoolean(), hasNextXXX, etc
- ALSO HAS METHOD .findInLine(regexString) that will return the next match!!!

> printf/format("specifiers", "string") are the SAME THING! USED BOTH BY SCANNER AND PRINTWRITER!!!
- SYNTAX IS: %[arg_index$][flags][width][.precision]conversion char
- arg_index$ means which of the argument to be printed at this position
- flags are: - (left justify), + (include a sign, requires spec. width), 0 (left pad with zeroes), use def locale group separators (,), ( (enclose neg in paranthesis)
- width is minimum number of chars to print INCLUDING precision, NOT JUST the part before decimal point
- .precision is numbers to print after the decimal point
- conversion acceptable characters are: b, c (char), d (integer), f (floating point), s (string)
- IF CONVERSION FAILS YOU GET IllegalFormatConversionException!!!
- %b will only return false for null and false boolean value, for all other types, including String "false" or 0 it will return true
> printf/format works wrapper objects too! (conversion will be done)
> %f will not accept ints!!! just float and double

> String
- only literal strings are automatically added to the pool. two objects pointing there will be equal using ==
- Strings computed at runtime are always NEW strings: like string resulted as ("Hello" + var) where var is a variable
- To add runtime strings to the pool you must use s = s.intern()!!! But until java 7 it is a bad idea and will eventually OutOfMemoryError: PermGen space 
- somestring.replace ("whattoreplace", "replacement") is the correct usage
- string has length() method, array has length property, collections have size() method
- new String("smth") will create 2 objects; one unreferenced literal in the string pool, and a new refed heap String
- String has .split(regexDelimiter) method that tokenizes string into an array of string tokens
- In String.split, all TRAILING delimiters are discarded (not the ones in middle). e.g. "one;;two;;;" => "one", "", "two" (length 3) 
- natural ordering of strings is alphabetical (like in dictionary) and not related to string length

------------------------------------------------------------------------------------------
Chapter 7: Generics and Collections
------------------------------------------------------------------------------------------
> You don't specify dimensions when using array initializers. int[] a = new int[2]{1,2} is incorrect.
> You cannot use Generic specifiers defined at class level (like <T>) in static methods. 
- Make it a generic static method separately by using the static <U> getStuff(U u) syntax
> Passing a generic collection to a non generic collection method parameter will result in warning ONLY if the method ADDS something
> Passing a non generic collection to a generic collection method parameter will result in warning
> You can't call add on a collection<? extends Something>, which has ?extends wildcard param. Compile error! YOU CAN ON "? super String"!!!!
> you can declare a class with a name that is the same as the type parameter placeholder: class X { public <X> X(X x) { } }
> PriorityQueue 
- is NOT a List, it is a Queue
- has (int maxelements, comparator<T>) constructor
- add() and offer() do the same thing; poll removes minimum; peek gets minimum without removing
- provides no non-destructive traversal methods. poll (get head) and remove (from anywhere) are used.
> HashMap
- can have one null key
- values() returns a Collection that does not guarantee any ordering
> LinkedHashMap maintains insertion order by default BUT
- it has a special constructor LinkedHashMap(int initialcapacity, int loadfactor, boolean lastAccessed) to favor last accessed iteration
> A map cannot contain itself as a key (compiles,but bad practice -mutable key) but can contain itself as a value
> Default ArrayList max elements is 10 when not specified
> Collections utility class
- sort(List) or sort(list, comparator) throw ClassCastException if the elements are not comparable (ml do not implement Comparable)
> Arrays throw ArrayIndexOutOfBoundsException when accesing an element at an index >= size. if size=0 then even a[0]
> Arrays throw ArrayStoreException if we add a Dog into a Cat array through an Animal reference.
> Arrays utility class 
- if the elements are not comparable (ml do not implement Comparable) sort() throws ClassCast exception
- sort(...) has no overload for privitive types that also take a Comparator!!!
- sort(...) alter the objects they get as a parameter! THEY RETURN void (also for lists, not just arrays)
- binarySearch(arr, key [,comparator]) must use the same comparator to return relevant results
- if binarySearch(...) does not find the element it returns -insertionPoint -1 where insertionpoint is indexof first elem > key
> Comparator has int compare(T a, T b) AND Comparable has int compareTo(T other)
> Comparable/Comparator can also be implemented non-generic!!! Then, the parameters will be Object.
> Comparator has static .reverseOrder() method that returns a comparator that imposes reverse natural ordering (usable for natural-order types)
- comparator.reversed() is a non-static method of a comparator instance that can return a new comparator that imposes reverse order of the current one
> list.toArray() returns a NEW array containing elements of the list; it comes with a param version to use specific destination array
> Arrays.asList(array) returns a Collection lively backed up by the specific array. Changes to one update both, unlike toArray result
> AbstractList's removeRange(firstIndexIncl, lastIndexExcl) is PROTECTED. Please use .sublist(f,lexcl).clear() which delegates to removeRange internally.
> TreeSet (methods)
- NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
- SortedSet<E> subSet(E fromElement, E toElement) // like any java range, last element is exclusive, first is inclusive
- SortedSet<E> tailSet(E fromElement) // Returns live view set whose elements >= fromElement. 
- NavigableSet<E> tailSet(E fromElement, boolean inclusive) // ~//~ greater than (or equal to, if inclusive is true) fromElement.
- headSet(E) and headSet(E,b) work exactly the same only headset(E) return elements STRICTLY smaller
- ceiling(E) and floor(E) will return elements greater OR EQUAL, respectively lower or EQUAL to the specified elem or null if not ex
- higher(E) and lower(E) will return elements STRICTLY greater, respectively STRICTLY lower to the specified elem or null if not ex
- first(), last() will return the respective elements.
- descendingSet() will return a reversely sorted TreeSet
- pollFirst(), pollLast() also work returning and also removing the respective elements
- Please note that many of this methods are also available for TreeMap (e.g. firstEntry, ceilingKey, pollLastEntry, descendingMap)
- REMEMBER: if you add an out of range element to a live subSet, you get java.lang.IllegalArgumentException: key out of range
> constructors CANNOT be synchronized! They don't normally have to because the obj is available only to creating thread 
> Set add will only add element if it's new. (returns false if not new). Map put will overwrite associated value.

------------------------------------------------------------------------------------------
Chapter 8: Inner Classes
------------------------------------------------------------------------------------------
> Inner classes can also be declare private or protected
- Inner classes access modifiers apply independently of the parent class (e.g. package-private inner class in public class)
> When you instantiate inner class you do Outer.Inner inner = outer.new Inner(); // you do not requalify the new part!!!
> When you instantiate static nested class you do Outer.StaticNested staticNested = new Outer.StaticNested(); // both parts 'Outer' qualified
> It is valid that an inner class CAN extend its parent class
> You cannot have an inner class with the same name as its parent
> An inner class has has access to all members of the parent class, including private ones
> You CAN'T have NON-FINAL static declarations inside an inner (non-static) class!!! In a static one you can.
- final static declarations (constants) are ok inside inner classes
> You can't instantiate an inner class like new InnerClass() from a static method of the outer class because there is no <this>
> .this points to the inner class instance. to point to the outer class instance you can use Outer.this
> A method local inner class can be declared abstract OR final, but not any other modifier like public/private, etc
> when creating an anonymous class like A a = new A(){}; the semicolon at the end is needed and ommiting it is a compile error!
> You can only call methods on an annonymous class which the defined reference type knows about (usual thing for non-ann classes)
> An annonymous type can only extend or implement a class, resp. an interface at a time. No way around this!
> An anonymous class cannot be declared static
> An anonymous class cannot have constructors
> An anonymous class must respect the constructors of an abstract class and must be declared as new AbstractClass(someparam) {...}
  if the abstract class has no other constructors except de parameterized one. Else, compiler error!
> The syntax for instantiating a static nested class is BigOuter.Nest n = new BigOuter.Nest();

------------------------------------------------------------------------------------------
Chapter 9: Threads
------------------------------------------------------------------------------------------
> The methods that throw InterruptedException are object.wait, Thread.sleep and t.join()
> calling interrupt() will cause an InterruptedException ONLY if the thread on which interrupt() is called, is blocked on an invocation of the wait(...), join(...), or sleep(...), methods of this class
> sleep and yield are STATIC. pay attention if they are called on a referenced thread. Only the current is affected!
> There is NO lock or resume method!
> Thread priorities (1-10) are the higher, the more critical (unlike priority queues where lower is urgent).
> Default thread priority is 5 (NORM_PRIORITY) for the main thread, and the INHERITED PARENT PRIORITY for all other threads
> Threads can be started from virtually EVERYWHERE, including init blocks, constructors and inner classes
> Two threads can deadlock if they sync on each other's instances, or synchronize lock two resources in nested reverse order.
- They will not deadlock if only one resource is waited for by both of them; it will eventually become available
- Multiple threads CAN deadlock at once.
- Using yield will not fix deadlock-able code.
> watch out! when a method synchronized but not static and changes a static field IS IS NOT THREAD SAFE. it must be made static!!!
> Methods that read must also be synchronized to make a class thread safe
> Only synchronizing write methods is not enough!, Reading methods must be synchronized as well. Also, on the SAME MONITOR, else NO effect.
> Synchronizing the run method is pointless as two threads will have their own instance!!!

------------------------------------------------------------------------------------------
Chapter 10: Development
------------------------------------------------------------------------------------------
> Command javac Someclass.java SomeOtherClass.java
- cp "path1;path2" can specify directories to scan as classpath roots to resolve classes (.class), in that order. Also: ;win :linux 
- classpath is by default the current directory (excluding classes right here). 
- Make sure you add . if you want to resolve .class in EXACTLY the current dir. Subfolders of . are automatically resolved
- overriding classpath using -cp or -classpath will REPLACE settings from CLASSPATH env variable
- -d classes specifies where to put the output
- will create package hierarchy under output dir if compiled class is in a package other than default one
- jars from $JAVA_HOME/jre/lib/ext/*.jar get added to cp automatically; also the ones specified in $CLASSPATH environment variable
- -source 1.3 is the LAST ONE to NOT consider assert a keyword!!! Starting from 1.4 it is a keyword!
> Command jar -cf JarFileName classesdir
- when -f is used file name must follow (not required to end in .jar) 
- META-INF is automatically created. no need to exist before command. It will not contain classes!
- -c means to create new archive, -u to update existing one
- you should not put java files in the META-INF folder. Compiled classes will start from root and not be in this folder
> Command java SomeClass
- -ea is only used for running, not compiling. It is required to enable assertions; 
- -esa is used to enable assertions for system classes
- -ea:possiblyqualified.Class or -ea:somepackage... , (yes with ellipsis) can enable assertions only in certain places
- -da:possiblyqualified.Class or -da:somepackage... may be used for disabling assertions in certain sub-places
- java -cp classes somepackage.Someclass // -cp specifies the classpath root. Someclass in package somepackage will run
- there can be more classpaths, separated by File.pathSeparator (;win, :linux), search stops at first find.


------------------------------------------------------------------------------------------
Extras / Curiosities
------------------------------------------------------------------------------------------
> Q: Which Set implementation does LinkedHashMap.keySet() use? 
  A: It's NOT LinkedHashSet as you might expect, but HashMap$KeySet (private type).
- It does guarantee order of insertion! It is not sorted!
> If you find a compilation problem and there are other CORRECT statements dependendent on the problematic class
  you only point the FIRST problem, and consider the dependent statements ok! (ex. inherited uncompilable class)
> (Java7) If you call somestring.intern() on a string will add this string to the pool or return the already pooled string
- you usually want to replace the strings with its interned value by doing s = s.intern(). This is to preserve memory.
> Two implemented interfaces have same const & YOU USE IT (only then) => field ambigous compiler error!
> Math.round(float) returns int and Math.round(double) returns long. they may be used to do real rounding (not for printing)
  using something like double x = 100.55; x = x * 100; x = (double) Math.round(x); x = x / 100;
> String "+" operator actually uses stringbuilder.append internally

------------------------------------------------------------------------------------------
To be checked (for in progress exams / curiosities)
------------------------------------------------------------------------------------------