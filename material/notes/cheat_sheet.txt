------------------------------------------------------------------------------------------
Chapter 1: Declarations and Access Control
------------------------------------------------------------------------------------------
> short is always -32768 to 32767. It is NOT platform dependent.
> Integer caches -128 to 127 objects created through any other means than new operator
  (autoboxed literals, Integer.valueOf("")), meaning same object will be returned
- parseInt returns primitive int, valueOf returns wrapper (Integer)
- parseInt, constructor(String) can throw NumberFormatException if string is invalid
> Permitted access modifiers for top level classes are only: public and (package-private)
> Default constructor always inherits access modifier of class
> if you implement an interface you must declare the methods public. leaving them package-private is c. ERROR
> A final class field must always be explicitly initialized inline, in constructor or in initializer
> Interface implicits!!!
- REMEMBER: constants in interfaces are NOT necessary to be declared public static final, but any or none of these (rest of modifiers will be added auto)
- REMEMBER: methods in an interface are NOT necessary to be declared public abstract, but any or none of these (rest of modifiers will be added auto)
- ANY OTHER MODIFIERS like private/protected for the above cases will result in COMPILER ERROR 
> strictfp can be applied to methods, classes and interfaces
> If a class is not public (say package-private), its public variables will NOT be available to ANY class (in this case, only to classes in the package) 
> Local (method) variables are also called automatic variables
> abstract method cannot be native

------------------------------------------------------------------------------------------
Chapter 2: Object Orientation
------------------------------------------------------------------------------------------
> you cannot hide a method using static method in the derived class! 
- the reverse is also true; you also cannot hide a static method using a method.
> In order to override, the parameters of the derived method should be exactly the same. (Parameter type invariance)
- Covariant (more derived) or contravariant (ancestor type) parameters are NOT valid overrides, BUT LEGAL OVERLOADS!!!
- Covariant return types are permitted but only for objects! NOT FOR PRIMITIVES.
- Legal signature of equals is always: public boolean equals(Object other); you cannot use class type as parameter
> super and this cannot be used from a static context (like main)
> You CAN'T do "this.super" or "var.super"
> You CAN'T call super-superclass's method if it was overriden by superclass!!!
> No comma (,) between extends and implements. Comma is used only to separate multiple interfaces
> No multiple use of implements keyword. Use comma for multiple interfaces
> An interface can extend multiple other interfaces
> Interface methods CAN declare exceptions!
> It's a compiler error to assign a new Base object to a derived reference. If you cast => ClassCastExc at runtime
> Finalize
- You can call finalize by hand BUT it acts just as a simple method call (no special meaning)
- GC will only run finalize once (it remebers this)
- Objects can be saved from GC during finalization. The next time object is gc, finalize will not be called.
> Default equals = equal objects by memory address, default hashcode = memory address casted to int
> Default hashCode and equals are legal implementations, but hard to use. Overriding identical behavior is ok.
> IF a.equals(b) then a.hashCode() == b.hashCode(). If you override equals then you must override hashcode!
> By hashcode you identify the bucket (reducing time), then by equals you iterate to really find the object/key
> If a base class has a parameterized constructor, derivatives need to invoke it.
- It is valid that subclass can indirectly invoke the base parameterized constructor through another of its
  constructors, that call super(...) as it's first statement.
> BE CAREFUL of private constructors/method calls in the same class as the main method! they work!
> Strings declared inside a block/method will NOT be available for garbage collection (in java 6 anyway) after the method/block ends
> Objects that have references to them might still be garbage collected if those references are from objects also g.c. eligible (islands)

------------------------------------------------------------------------------------------
Chapter 3: Assignments
------------------------------------------------------------------------------------------
> Widening is preferred to boxing
> Varargs must be last argument
> Varargs are always considered last in overloading, even when we also have (Object) sgntr
> You can't widen then box, but you can box then widen! REMEMBER FIRST you BOX!!!
- e.g. you CAN int -> Integer -> Object (assigning to superclass is considered widening in wrappers)
- but you can't short -> long -> Long
- Integer (wrapper) increment and postincrement WORK! they really assign the value (create new obj).
> always think x+=y as x = (t) (x + y) and x++ as x = (t) (x+1)
> Boolean.valueOf or the constructor(String) of boolean returns true for a case insensitive tRuE, else false, never null
> Java performs implicit narrowing conversions of primitives when the context requires it when the value is the result of a constant expression only
- that means that char c = a * b where a and b are ints will not work because it's a runtime determined value!!!
> ints only upto 65565 - which is short maxvalue will cast directly to char; higher ints will give compile error.
> something like a [ (a=b) [k] ] where a and b are arrays will make a [...] still refer to the original a, and not b!!!

------------------------------------------------------------------------------------------
Chapter 4: Operators
------------------------------------------------------------------------------------------
> You can use logical or (xor) "^" to return true from mixing two different valued booleans
> << and >>> are actually the opposites. >> keeps sign bit, >>> has more force and pulls it
> Correct syntax is a instanceof ClassNameOnly-NotAVariableNotAnExpression. NO PARANTHESIS~~!
- it will return true if a is a ClassNameOnly (or a subclass of it).
> ~ only applies to ints (bitwise not)
> *, / and % all have the same level of precedence

------------------------------------------------------------------------------------------
Chapter 5: Flow Control, Exceptions, and Assertions
------------------------------------------------------------------------------------------
> you can call instance methods in inline field initialization, and they will use the state variables initialized until reaching the current var initialization
- for inline initialized variables after the current initialization, it will not know about this and will use default values (0 / null)
> you can label: { } block, and IT IS LEGAL TO do break label; from a loop inside this block and it will go the the end of the block  
> Assertions should gen. be used to validate private method args. Validating public input is inappropriate (e.g. args of main)
- Assertions like "assert false" are appropriate to use in any method to mark a location where code should not reach.
- asserting a false statement throws AssertionError => program exits unless the error is caught
- asserting a modifying statement is bad practice. code will only modify is assertions are enabled.
- syntax is assert boolean_statement : non_void_return_statement where the 2nd will print to screen (usually a string)
- the 2nd expression can call modifiable code, but usually it doesn't matter anymore as the program doesn't catch the error and exits
> while(false) and for(;false;) are illegal. if(false) and do{}while(false)are legal!!
- for if(true) throw RuntimeException, any code following will NOT be considered UNREACHABLE! WHAT A HACK! :O
> for(int a = 0, b = 4 ; ; expression(), expression2()) is the correct syntax
- multiple declared variables are permitted but only of the SAME type.
- redefinition of other variables from the parent scope is illegal and is a tricky exam catch!!
- WATCH OUT FOR reusing FOR incrementing variables after closing the for scope!!! => Compile error!
- multiple incrementing expressions are permitted, and they don't have to necessarily increment
> You can add a throws declaration for any checked exception, even though it is not really thrown anywhere
> Order of caught exception MUST be from narrower to broader!!! else COMPILE ERROR!
> in switch it's "default:" not "case default:"

------------------------------------------------------------------------------------------
Chapter 6: Strings, I/O, Formatting and Parsing (API)
------------------------------------------------------------------------------------------
> java.util.Date is NOT immutable; it uses alterable epoch time
- Date(long milliseconds) is a valid constructor
- you can use getTime() to get the long value of milliseconds
- you can use setTime(long milliseconds) to modify the current date to other milliseconds value!!! 

> java.util.Calendar
- you obtain it using Calendar.getInstance();
- you can set date to it using calendar.setTime(date)
- you can also use set(year, month, day) BUT REMEMBER MONTH STARTS AT 0 (ZERO) or you could use Calendar.JANUARY
- c.add(Calendar.HOUR, 1) or c.roll(Calendar.MONTH, 11) works; roll is like add only it leaves larger units as it and recycles through specified unit
- c.get(Calendar.DAY_OF_MONTH) returns day of month(e.g.31); you don't have to know all fields for exam
- calendar.getTime() obtains a Date represented by this calendar

> java.text.DateFormat
- BOTH DateFormat and NumberFormat CAN ONLY set LOCALE at the moment of instantiation!!! The is NO METHOD TO CHANGE IT AFTERWARDS
- DateFormat.getDateInstance(), DateFormat.getDateInstance(int DateFormat.LONG) return date formats for default locale
- DateFormat.getDateInstance(int DateFormat.LONG, locale); will get a Dateformat object for that
- same for DateFormat.getTimeInstance(...), they still use the following int DateFormat.* constants for time formats (please infer)
- getDateTimeInstance(...) also exists and it's the only one that retains time!!!
- SHORT = 12.13.52, MEDIUM (default for getDATEInstance() = Jan 12, 1952, LONG = January 12, 1952, FULL = Tuesday, April 12, 1952 AD
- DateFormat.getInstance() exist... but without params, uses SHORT for both date and time formatting! not used frequently
- df.parse("string") will return a Date and will throw checked exception ParseException!!! treat it!
- df.format(java.util.Date) that returns a formatted date String

> java.text.NumberFormat
- NumberFormat.getInstance(locale) gets number formatter for specific locale
- NumberFormat.getCurrencyInstance(locale) gets number formatter for specific locale; curiosity: f.setCurrency(Currency.getInstance("EUR")) can further set currency
- NumberFormat.getPercentInstance(locale) also exists.
- There are methods .getInstance() and .getCurrencyInstance() - and will use current locale
- nf.parse returns a Number, the kind of what it has parsed
- you can use nf.setParseIntegerOnly(true) to only further consider integer parts of floating point number strings
- nf.format(Number) that returns a formatted number String; throws arithmetic exc if roundingmode is set to unnecessary
- nf.setRoundingMode(RoundingMode) can set rounding mode; IF NOT SPECIFIED IS HALF_EVEN. round up usually, unless 0.5 then round to nearest EVEN number
- nf.setMaximumFractionDigits and nf.setMinimumFractionDigits will be respected, ROUNDING WILL BE APPLIED when using format(...)

> java.util.Locale
- getDefault() gets current default locale!!! remember JUST getDefault()!!!
- new Locale(language); or Locale(language, country);
- example new Locale("it","CH"); // Switzerland
- you can also use Locale.CANADA constants for some important countries
- there are also methods loc.getDisplayCountry() and loc.getDisplayLanguage() that will return the name of country/language in cur locale (english)
- to return the name of country/language in other locales, you can use the parameterized versions like getDisplayLanguage(otherLocale) 

> To get -D passed properties you do: System.getProperty("x") or System.getProperties().getProperty("x")
- you use System.getenv("var"); [ yes with non capital env ] to a an environment variable

> StringBuilder
- notable methods: append(String), insert(int,String), reverse(), delete(startIncl, end), toString()
- replace(...) with 2 args(what,withwhat) or 3 args(first,lastNotIncl,withwhat)
- is only available from java 1.5 onward
> MOST FILE OPERATIONS THROW EXCEPTIONS
> File
- constructors (string) or (File directory, String)
- has methods exists(); createNewFile() - which really creates,equals then updated returns true if created;
- file cannot be closed, only readers and writers do
- Directories. You can use the following methods on File: boolean mkdir()
- file.list() returns a string array of file names in the dir. list() does NOT throw any checked exceptions
- other methods isDirectory(), isFile(), renameTo(File) - can actually also move a file
> FileReader [[ < BufferedReader ; FileWriter < BufferedWriter < PrintWriter ]], all construct from filenamestring or File
- FileReader has int read(char[]) reads the whole file, returns int size read; read() 1 char; read(char[], arroffset, length)
> BufferedReader has methods String readline() - it returns null when all lines have been read. THERE IS NO hasNext method in FileReader(s), only in scanner 
> FileWriter
- has write(String) - writes characters to file, has flush() may be called before close; write(char[]/String, offset, length) 
> BufferedWriter - has newLine method.
> PrintWriter - has print(..), println(..), format(..) and printf/format(..)
> System.console() returns the console INSTANCE as java.io.Console, we CAN'T get it with "new"
- method c.readPassword("%s", "pw: ") always reads the password in a char array and without echoing user input
- method c.readLine("%s", "input?: "); contains an element entered by the user (see format)
- method c.format("output: %s \n", str); prints something on the screen using format
> Serialization syntax
- FileOutputStream fs = new FileOutputStream("testSer.ser"); ObjectOutputStream os = new ObjectOutputStream(fs);
- os.writeObject(c); os.close();} catch (Exception e)
- FileInputStream fis = new FileInputStream("testSer.ser"); ObjectInputStream ois = new ObjectInputStream(fis);
- c = (Cat) ois.readObject(); ois.close();} catch (Exception e) { e.printStackTrace(); } // CAST OBJECT AT READ!!!
- java.io.NotSerializableException if one non-transient nested object is not serializable
- to custom serialize a field, you declare it at transient!!! then:
- object can define two private methods: private VOID readObject(OIS) and private void writeObject(OOS) // BOTH THROW EX
- inside them you writeInt/writeObject on the stream and before or after call defaultWriteObject() or defaultReadObject()
- keep order of custom written fields in both writeObject(OOS) and readObject(OIS)
- In deserialization, all constructors of the non-serializable superclasses will call. 
- Fields of those non-serializable superclasses will not serialize, unless done manually using writeobj(oos)
- constructors and field initializers + initializers from the first serializable superclass will NOT call

> Regex
- general usage is: Pattern p = Pattern.compile("\\s"); Matcher m=p.matcher("word"); 
  while(m.find()){ syso (m.group()) } next sequence OR
  m.matches() attempts to match whole word with pattern
- you can also use inside find m.start() //indexstart + " " + m.end() // indexafterlast
- "?" means 0 or 1 occurences, "*" 0 or more, "+" 1 or more
- group will throw IllegalStateException if find (or match) wasn't called before
- once matched, a group of chars are consumed, and will be skipped for the next find()
- \\d means digit, \\s means space, \\w means word (letters, digits or underscore)
- [^ab] will find any char that is not a or b

> Scanner 
- has constructor new Scanner (String), Scanner (File), and ofc inputstream but not discussed
- has methods useDelimiter( STRING not char ) // IT IS NOT SETDELIMITER, BUT USE!!! SCANNER USE DELIMITER
- methods nextInt throw java.util.InputMismatchException if format not ok;
- also has methods next() and nextLine() for reading next token by delimiter, or next line and also boolean hasNext()!!!
- for has methods, they also exist in the form of hasNextBoolean(), hasNextXXX, etc
- ALSO HAS METHOD .findInLine(regexString) that will return the next match!!!

> printf/format("specifiers", "string") are the SAME THING! USED BOTH BY SCANNER AND PRINTWRITER!!!
- SYNTAX IS: %[arg_index$][flags][width][.precision]conversion char
- arg_index$ means which of the argument to be printed at this position
- flags are: - (left justify), + (include a sign), 0 (left pad with zeroes), use def locale group separators (,), ( (enclose neg in paranthesis)
- width is minimum number of chars to print INCLUDING precision, NOT JUST the part before decimal point
- .precision is numbers to print after the decimal point
- conversion acceptable characters are: b, c (char), d (integer), f (floating point), s (string)
- IF CONVERSION FAILS YOU GET IllegalFormatConversionException!!!
- %b will only return false for null and false boolean value, for all other types, including String "false" or 0 it will return true

> String
- only literal strings are automatically added to the pool. two objects pointing there will be equal using ==
- somestring.replace ("whattoreplace", "replacement") is the correct usage
- string has length() method, array has length property, collections have size() method
- new String("smth") will create 2 objects; one unreferenced literal in the string pool, and a new refed heap String
- String has .split(regexDelimiter) method that tokenizes string into an array of string tokens
- Strings computed at runtime are always NEW strings: like string resulted as ("Hello" + var) where var is a variable

------------------------------------------------------------------------------------------
Chapter 7: Generics and Collections
------------------------------------------------------------------------------------------
> You don't specify dimensions when using array initializers. int[] a = new int[2]{1,2} is incorrect.
> You cannot use Generic specifiers defined at class level (like <T>) in static methods. 
- Make it a generic static method separately by using the static <U> getStuff(U u) syntax
> PriorityQueue 
- is NOT a List, it is a Queue
- has (int maxelements, comparator<T>) constructor
- add() and offer() do the same thing; poll removes minimum; peek gets minimum without removing
- provides no non-destructive traversal methods. poll (get head) and remove (from anywhere) are used.
> HashMap
- can have one null key
- values() returns a Collection that does not guarantee any ordering
> Default ArrayList max elements is 10 when not specified
> Collections utility class
- sort(List) or sort(list, comparator) throw ClassCastException if the elements are not comparable (ml do not implement Comparable)
> Arrays throw ArrayIndexOutOfBoundsException when accesing an element at an index >= size. if size=0 then even a[0]
> Arrays utility class if the elements are not comparable (ml do not implement Comparable)
- sort() throws ClassCast exception of 
- binarySearch(arr, key [,comparator]) must use the same comparator to return relevant results
- if binarySearch(...) does not find the element it returns -insertionPoint -1 where insertionpoint is indexof first elem > key
> Comparator has int compare(T a, T b) AND Comparable has int compareTo(T other)
> Comparable/Comparator can also be implemented non-generic!!! Then, the parameters will be Object.
> AbstractList's removeRange(firstIndexIncl, lastIndexExcl) is PROTECTED. Please use .sublist(f,lexcl).clear() which delegates to removeRange internally.
> TreeSet (methods)
- NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)
- SortedSet<E> subSet(E fromElement, E toElement) // like any java range, last element is exclusive, first is inclusive
- SortedSet<E> tailSet(E fromElement) // Returns live view set whose elements >= fromElement. 
- NavigableSet<E> tailSet(E fromElement, boolean inclusive) // ~//~ greater than (or equal to, if inclusive is true) fromElement.
- headSet(E) and headSet(E,b) work exactly the same only headset(E) return elements STRICTLY smaller
- ceiling(E) and floor(E) will return elements greater OR EQUAL, respectively lower or EQUAL to the specified elem or null if not ex
- higher(E) and lower(E) will return elements STRICTLY greater, respectively STRICTLY lower to the specified elem or null if not ex
- REMEMBER: if you add an out of range element to a live subSet, you get java.lang.IllegalArgumentException: key out of range
- adding an existing item (compare 0) to TreeSet, will IGNORE THE NEW INSTEAD OF REPLACING THE CURRENT, unlike HashSet
> You can't call add on a collection<? extends Something>, which has ?extends wildcard param. Compile error! YOU CAN ON "? super String"!!!!
> Array let's you get away with putting a Cat in an Animal array reference which references a Dog array object.
> constructors CANNOT be synchronized! They don't normally have to because the obj is available only to creating thread

------------------------------------------------------------------------------------------
Chapter 8: Inner Classes
------------------------------------------------------------------------------------------
> Inner classes can also be declare private or protected
- Inner classes access modifiers apply independently of the parent class (e.g. package-private inner class in public class)
> When you instantiate inner class you do Outer.Inner inner = outer.new Inner(); // you do not requalify the new part!!!
> When you instantiate static nested class you do Outer.StaticNested staticNested = new Outer.StaticNested(); // both parts 'Outer' qualified

------------------------------------------------------------------------------------------
Chapter 9: Threads
------------------------------------------------------------------------------------------
> The methods that throw InterruptedException are object.wait, Thread.sleep and t.join()
> sleep and yield are STATIC. pay attention if they are called on a referenced thread. Only the current is affected!
> Thread priorities (1-10) are the higher, the more critical (unlike priority queues where lower is urgent).
> Default thread priority is 5 (NORM_PRIORITY) for the main thread, and the INHERITED PARENT PRIORITY for all other threads
> Threads can be started from virtually EVERYWHERE, including init blocks, constructors and inner classes
> Two threads can deadlock if they sync on each other's instances, or synchronize lock two resources in nested reverse order.
- They will not deadlock if only one resource is waited for by both of them; it will eventually become available
- Multiple threads CAN deadlock at once.
- Using yield will not fix deadlock-able code.
> watch out! when a method synchronized but not static and changes a static field IS IS NOT THREAD SAFE. it must be made static!!!
> Methods that read must also be synchronized to make a class thread safe

------------------------------------------------------------------------------------------
Chapter 10: Development
------------------------------------------------------------------------------------------
> Command javac Someclass.java SomeOtherClass.java
- cp "path1;path2" can specify directories to scan as classpath roots to resolve classes (.class), in that order. Also: ;win :linux 
- classpath is by default the current directory. Make sure you add . if you redefine this and want to resolve .class in current dir.
- -d classes specifies where to put the output
- will create package hierarchy under output dir if compiled class is in a package other than default one
- jars from $JAVA_HOME/jre/lib/ext/*.jar get added to cp automatically; also the ones specified in $CLASSPATH environment variable
- -source 1.3 is the LAST ONE to NOT consider assert a keyword!!! Starting from 1.4 it is a keyword!
> Command jar -cf JarFileName classesdir
- when -f is used file name must follow (not required to end in .jar) 
- META-INF is automatically created. no need to exist before command. It will not contain classes!
- -x means to create new archive, -u to update existing one
- you should not put java files in the META-INF folder. Compiled classes will start from root and not be in this folder
> Command java SomeClass
- -ea is only used for running, not compiling. It is required to enable assertions
- -ea:possiblyqualified.Class or -ea:somepackage... , (yes with ellipsis) can enable assertions only in certain places
- java -cp classes somepackage.Someclass // -cp specifies the classpath root. Someclass in package somepackage will run
- there can be more classpaths, separated by File.pathSeparator (;win, :linux), search stops at first find.


------------------------------------------------------------------------------------------
Extras / Curiosities
------------------------------------------------------------------------------------------
> Q: Which Set implementation does LinkedHashMap.keySet() use? 
  A: It's NOT LinkedHashSet as you might expect, but HashMap$KeySet (private type).
- It does guarantee order of insertion! It is not sorted!
> If you find a compilation problem and there are other CORRECT statements dependendent on the problematic class
  you only point the FIRST problem, and consider the dependent statements ok! (ex. inherited uncompilable class)
> (Java7) If you call somestring.intern() on a string will add this string to the pool or return the already pooled string
> Two implemented interfaces have same const & YOU USE IT (only then) => field ambigous compiler error!
> Math.round(float) returns int and Math.round(double) returns long. they may be used to do real rounding (not for printing)
  using something like double x = 100.55; x = x * 100; x = (double) Math.round(x); x = x / 100;
> String "+" operator actually uses stringbuilder.append internally